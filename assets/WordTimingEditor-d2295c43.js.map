{"version":3,"file":"WordTimingEditor-d2295c43.js","sources":["../../src/models/RelativeSyllableTiming.ts","../../src/components/WordTimingEditor.vue"],"sourcesContent":["import { TIMING } from '@/models/TimingConstants'\n\n/**\n * RelativeSyllableTiming - A proper TypeScript model for handling syllable timing\n *\n * Key Design Principles:\n * 1. Syllables are stored as relative offsets/durations from word start\n * 2. Word movement automatically moves all syllables (no manual sync needed)\n * 3. Word resizing only affects the last syllable\n * 4. Conversion methods handle absolute time calculations for UI display\n */\n\nexport interface RelativeSyllable {\n  text: string\n  startOffset: number  // Offset from word start (milliseconds)\n  duration: number     // Syllable duration (milliseconds)\n}\n\nexport interface AbsoluteSyllable {\n  text: string\n  startTime: number    // Absolute start time (milliseconds)\n  endTime: number      // Absolute end time (milliseconds)\n}\n\nexport interface TimedWordData {\n  id: string\n  text: string\n  startTime: number    // Milliseconds\n  endTime: number      // Milliseconds\n  syllables: RelativeSyllable[]\n}\n\nexport class RelativeSyllableTiming {\n  private word: TimedWordData\n\n  constructor(wordData: TimedWordData) {\n    this.word = { ...wordData }\n    this.validateSyllables()\n  }\n\n  /**\n   * Validate that syllables are properly structured\n   */\n  private validateSyllables(): void {\n    if (this.word.syllables.length === 0) {\n      throw new Error('Word must have at least one syllable')\n    }\n\n    let currentOffset = 0\n    for (const syllable of this.word.syllables) {\n      // Allow small rounding errors in offset alignment\n      const offsetError = Math.abs(syllable.startOffset - currentOffset)\n      if (offsetError > TIMING.validation.timingPrecision) {\n        throw new Error(`Syllable \"${syllable.text}\" has gap or overlap. Expected startOffset: ${currentOffset}, got: ${syllable.startOffset} (error: ${offsetError}ms)`)\n      }\n      if (syllable.duration <= 0) {\n        throw new Error(`Syllable \"${syllable.text}\" must have positive duration, got: ${syllable.duration}`)\n      }\n      currentOffset += syllable.duration\n    }\n\n    const expectedWordDuration = this.word.endTime - this.word.startTime\n    const actualSyllablesTotalDuration = currentOffset\n    if (Math.abs(expectedWordDuration - actualSyllablesTotalDuration) > TIMING.validation.durationTolerance) {\n      throw new Error(`Word duration (${expectedWordDuration}ms) doesn't match total syllable duration (${actualSyllablesTotalDuration}ms)`)\n    }\n  }\n\n  /**\n   * Get word data (immutable copy)\n   */\n  getWordData(): Readonly<TimedWordData> {\n    return { ...this.word }\n  }\n\n  /**\n   * Get word duration\n   */\n  getWordDuration(): number {\n    return this.word.endTime - this.word.startTime\n  }\n\n  /**\n   * Convert relative syllables to absolute positions for UI display\n   */\n  getAbsoluteSyllables(): AbsoluteSyllable[] {\n    return this.word.syllables.map(syllable => ({\n      text: syllable.text,\n      startTime: this.word.startTime + syllable.startOffset,\n      endTime: this.word.startTime + syllable.startOffset + syllable.duration\n    }))\n  }\n\n  /**\n   * Move word to new start time - syllables automatically follow\n   */\n  moveWord(newStartTime: number): RelativeSyllableTiming {\n    const duration = this.getWordDuration()\n    return new RelativeSyllableTiming({\n      ...this.word,\n      startTime: newStartTime,\n      endTime: newStartTime + duration\n    })\n  }\n\n  /**\n   * Resize word by changing end time - only affects last syllable\n   */\n  resizeWordEnd(newEndTime: number): RelativeSyllableTiming {\n    if (newEndTime <= this.word.startTime) {\n      throw new Error('Word end time must be after start time')\n    }\n\n    const newWordDuration = newEndTime - this.word.startTime\n    const syllables = [...this.word.syllables]\n\n    if (syllables.length === 1) {\n      // Single syllable: adjust its duration\n      syllables[0] = {\n        ...syllables[0],\n        duration: newWordDuration\n      }\n    } else {\n      // Multi-syllable: only adjust last syllable duration\n      const lastIndex = syllables.length - 1\n      const lastSyllableStartOffset = syllables[lastIndex].startOffset\n      const newLastSyllableDuration = newWordDuration - lastSyllableStartOffset\n\n      if (newLastSyllableDuration <= 1) { // 1ms minimum duration\n        throw new Error('Resizing would make last syllable have zero or negative duration')\n      }\n\n      syllables[lastIndex] = {\n        ...syllables[lastIndex],\n        duration: newLastSyllableDuration\n      }\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      endTime: newEndTime,\n      syllables\n    })\n  }\n\n  /**\n   * Resize word by changing start time - only affects first syllable\n   */\n  resizeWordStart(newStartTime: number): RelativeSyllableTiming {\n    if (newStartTime >= this.word.endTime) {\n      throw new Error('Word start time must be before end time')\n    }\n\n    const newWordDuration = this.word.endTime - newStartTime\n    const syllables = [...this.word.syllables]\n\n    if (syllables.length === 1) {\n      // Single syllable: adjust its duration and reset offset to 0\n      syllables[0] = {\n        ...syllables[0],\n        startOffset: 0,\n        duration: newWordDuration\n      }\n    } else {\n      // Multi-syllable: adjust first syllable duration, shift others\n      const oldFirstDuration = syllables[0].duration\n      const newFirstDuration = newWordDuration - (this.getWordDuration() - oldFirstDuration)\n\n      if (newFirstDuration <= 1) { // 1ms minimum duration\n        throw new Error('Resizing would make first syllable have zero or negative duration')\n      }\n\n      const deltaOffset = oldFirstDuration - newFirstDuration\n\n      // Adjust first syllable\n      syllables[0] = {\n        ...syllables[0],\n        startOffset: 0,\n        duration: newFirstDuration\n      }\n\n      // Shift all other syllables\n      for (let i = 1; i < syllables.length; i++) {\n        syllables[i] = {\n          ...syllables[i],\n          startOffset: syllables[i].startOffset - deltaOffset\n        }\n      }\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      startTime: newStartTime,\n      syllables\n    })\n  }\n\n  /**\n   * Move and resize word in one operation\n   */\n  moveAndResize(newStartTime: number, newEndTime: number): RelativeSyllableTiming {\n    if (newStartTime >= newEndTime) {\n      throw new Error('Word start time must be before end time')\n    }\n\n    // First move, then resize\n    return this.moveWord(newStartTime).resizeWordEnd(newEndTime)\n  }\n\n  /**\n   * Adjust individual syllable boundary\n   */\n  adjustSyllableBoundary(syllableIndex: number, newEndTime: number): RelativeSyllableTiming {\n    if (syllableIndex < 0 || syllableIndex >= this.word.syllables.length - 1) {\n      throw new Error('Can only adjust boundaries between syllables')\n    }\n\n    const absoluteNewEndTime = newEndTime - this.word.startTime\n    if (absoluteNewEndTime <= this.word.syllables[syllableIndex].startOffset ||\n      absoluteNewEndTime >= this.word.syllables[syllableIndex + 1].startOffset + this.word.syllables[syllableIndex + 1].duration) {\n      throw new Error('New syllable boundary is outside valid range')\n    }\n\n    const syllables = [...this.word.syllables]\n    const currentSyllable = syllables[syllableIndex]\n    const nextSyllable = syllables[syllableIndex + 1]\n\n    // Adjust current syllable's duration\n    const newCurrentDuration = absoluteNewEndTime - currentSyllable.startOffset\n    syllables[syllableIndex] = {\n      ...currentSyllable,\n      duration: newCurrentDuration\n    }\n\n    // Adjust next syllable's start offset and duration\n    const nextSyllableEndOffset = nextSyllable.startOffset + nextSyllable.duration\n    syllables[syllableIndex + 1] = {\n      ...nextSyllable,\n      startOffset: absoluteNewEndTime,\n      duration: nextSyllableEndOffset - absoluteNewEndTime\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      syllables\n    })\n  }\n\n  /**\n   * Create from legacy absolute syllable data (expects milliseconds)\n   * Automatically fixes small gaps/overlaps in syllable timing\n   */\n  static fromAbsoluteSyllables(wordId: string, wordText: string, wordStartTime: number, wordEndTime: number, absoluteSyllables: AbsoluteSyllable[]): RelativeSyllableTiming {\n    if (absoluteSyllables.length === 0) {\n      throw new Error('Must have at least one syllable')\n    }\n\n    // Clean up syllable timing to ensure continuity\n    const cleanedSyllables: AbsoluteSyllable[] = []\n    let currentTime = wordStartTime\n\n    for (let i = 0; i < absoluteSyllables.length; i++) {\n      const syllable = absoluteSyllables[i]\n      const isLast = i === absoluteSyllables.length - 1\n\n      let startTime = Math.round(syllable.startTime)\n      let endTime = Math.round(syllable.endTime)\n\n      // Fix small gaps/overlaps using centralized tolerance\n      if (Math.abs(startTime - currentTime) <= TIMING.validation.gapTolerance) {\n        startTime = currentTime\n      }\n\n      // Ensure positive duration using centralized minimum\n      if (endTime <= startTime) {\n        const minDuration = Math.max(TIMING.validation.timingPrecision, TIMING.syllable.minDuration / 1000)\n        const minEndTime = startTime + minDuration\n        // console.warn(`⚠️ Fixed negative duration for syllable \"${syllable.text}\": was ${startTime}-${endTime}, now ${startTime}-${minEndTime}`)\n        endTime = minEndTime\n      }\n\n      // For last syllable, ensure it ends exactly at word end\n      if (isLast) {\n        endTime = Math.round(wordEndTime)\n      }\n\n      cleanedSyllables.push({\n        text: syllable.text,\n        startTime,\n        endTime\n      })\n\n      currentTime = endTime\n    }\n\n    // Convert to relative syllables with proper offset calculation\n    const relativeSyllables: RelativeSyllable[] = []\n    let expectedOffset = 0\n\n    for (const syllable of cleanedSyllables) {\n      const duration = syllable.endTime - syllable.startTime\n\n      // Ensure minimum duration\n      const safeDuration = Math.max(duration, TIMING.validation.timingPrecision)\n\n      if (duration <= 0) {\n        // console.warn(`⚠️ Fixed zero/negative duration for \"${syllable.text}\": ${duration}ms → ${safeDuration}ms`)\n      }\n\n      relativeSyllables.push({\n        text: syllable.text,\n        startOffset: expectedOffset, // Use expected offset, not calculated\n        duration: safeDuration\n      })\n\n      expectedOffset += safeDuration\n    }\n\n    // Calculate actual word duration from cleaned syllables\n    const actualWordDuration = relativeSyllables.reduce((sum, syl) => sum + syl.duration, 0)\n    const adjustedWordEndTime = Math.round(wordStartTime) + actualWordDuration\n\n    // If word duration changed significantly, log it\n    const originalWordDuration = Math.round(wordEndTime) - Math.round(wordStartTime)\n    if (Math.abs(actualWordDuration - originalWordDuration) > TIMING.validation.durationTolerance) {\n      // console.warn(`⚠️ Adjusted word \"${wordText}\" duration: ${originalWordDuration}ms → ${actualWordDuration}ms to match syllables`)\n    }\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(wordStartTime),\n      endTime: adjustedWordEndTime,\n      syllables: relativeSyllables\n    })\n  }\n\n  /**\n   * Create from UI data (converts seconds to milliseconds)\n   */\n  static fromSecondsData(wordId: string, wordText: string, wordStartSeconds: number, wordEndSeconds: number, syllableTexts: string[], lastSyllableWeight: number = 1.2): RelativeSyllableTiming {\n    const wordStartTime = Math.round(wordStartSeconds * 1000)\n    const wordEndTime = Math.round(wordEndSeconds * 1000)\n    return RelativeSyllableTiming.createWeightedSyllables(wordId, wordText, wordStartTime, wordEndTime, syllableTexts, lastSyllableWeight)\n  }\n\n  /**\n   * Convert to UI data (milliseconds to seconds)\n   */\n  toSecondsData(): { word: { id: string, text: string, startTime: number, endTime: number }, syllables: { text: string, startTime: number, endTime: number }[] } {\n    const absoluteSyllables = this.getAbsoluteSyllables()\n    return {\n      word: {\n        id: this.word.id,\n        text: this.word.text,\n        startTime: this.word.startTime / 1000,\n        endTime: this.word.endTime / 1000\n      },\n      syllables: absoluteSyllables.map(syl => ({\n        text: syl.text,\n        startTime: syl.startTime / 1000,\n        endTime: syl.endTime / 1000\n      }))\n    }\n  }\n\n  /**\n   * Create a simple word with even syllable distribution (expects milliseconds)\n   */\n  static createEvenSyllables(wordId: string, wordText: string, startTime: number, endTime: number, syllableTexts: string[]): RelativeSyllableTiming {\n    const wordDuration = Math.round(endTime - startTime)\n    const baseSyllableDuration = Math.floor(wordDuration / syllableTexts.length)\n    const remainder = wordDuration % syllableTexts.length\n\n    const syllables: RelativeSyllable[] = []\n    let currentOffset = 0\n\n    syllableTexts.forEach((text, index) => {\n      // Distribute remainder across first syllables to ensure exact total\n      const duration = baseSyllableDuration + (index < remainder ? 1 : 0)\n      syllables.push({\n        text,\n        startOffset: currentOffset,\n        duration\n      })\n      currentOffset += duration\n    })\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(startTime),\n      endTime: Math.round(endTime),\n      syllables\n    })\n  }\n\n  /**\n   * Create a word with weighted syllable distribution (last syllable gets more time) - expects milliseconds\n   */\n  static createWeightedSyllables(wordId: string, wordText: string, startTime: number, endTime: number, syllableTexts: string[], lastSyllableWeight: number = 1.2): RelativeSyllableTiming {\n    const wordDuration = Math.round(endTime - startTime)\n\n    // Calculate weights\n    const weights = syllableTexts.map((_, index) =>\n      index === syllableTexts.length - 1 ? lastSyllableWeight : 1.0\n    )\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n\n    // Create syllables with weighted durations (ensure integer milliseconds)\n    const syllables: RelativeSyllable[] = []\n    let currentOffset = 0\n    let totalAssigned = 0\n\n    syllableTexts.forEach((text, index) => {\n      let duration: number\n      if (index === syllableTexts.length - 1) {\n        // Last syllable gets whatever is left to ensure exact total\n        duration = wordDuration - totalAssigned\n      } else {\n        duration = Math.round((weights[index] / totalWeight) * wordDuration)\n        totalAssigned += duration\n      }\n\n      syllables.push({\n        text,\n        startOffset: currentOffset,\n        duration\n      })\n      currentOffset += duration\n    })\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(startTime),\n      endTime: Math.round(endTime),\n      syllables\n    })\n  }\n}\n","<!--\nWORD TIMING EDITOR COMPONENT - Design & Behavior Notes\n\nVISION:\n- Single unified timeline component (like a train track with word cars)\n- Horizontal 1px black line with word rectangles sitting on top (kabob-case style)\n- Positioned above waveform viewer for synchronized time viewing\n- Musical timing intelligence: captures word starts via spacebar, assumes note patterns\n\nDURATION-BASED WORKFLOW:\n- Think in terms of DURATIONS rather than end times (more musical/natural)\n- Move operations: preserve duration, change start time\n- Resize operations: preserve start time, change duration\n- Syllable proportions: stored as percentages of word duration\n- Visual width directly represents time duration\n\nBEHAVIORS:\n- Each word box width represents duration visually (start + duration = end)\n- Hot spots: move entire word (preserves duration), resize duration, syllable dividers\n- Smart syllable distribution: first syllables shorter, last longer (NOT equal triplets)\n- Time-locked with waveform: same scale, synchronized scrolling/zooming\n\nINTERACTION PATTERNS:\n- Spacebar tap captures word start times during playback\n- Dragging resize handle changes word duration intelligently\n- Moving words preserves their musical duration\n- Future: keyboard shortcuts for common duration adjustments (quarter note, eighth note, etc.)\n- Cursor feedback shows interaction type (grab/resize/divide)\n\nMUSICAL ASSUMPTIONS:\n- Words have natural durations that should be preserved when moving\n- Duration changes redistribute syllables proportionally (musical phrasing)\n- Start time capture + duration-based editing = natural musical workflow\n- Syllable timing follows musical phrasing (not mechanical equal spacing)\n-->\n\n<template>\n  <div class=\"word-timing-editor\">\n    <!-- Main timeline track with horizontal reference line -->\n    <div class=\"timeline-track\" :class=\"{\n      'with-background': showBackground,\n      'with-border': showBorder\n    }\" ref=\"timelineTrack\">\n      <!-- 1px black horizontal line (the \"track\" for word \"train cars\") -->\n      <div class=\"timeline-baseline\"></div>\n\n      <!-- Word boxes positioned as train cars on the track -->\n      <div v-for=\"word in visibleWords\" :key=\"word.id\" class=\"word-car\" :class=\"{\n        selected: selectedWordId === word.id,\n        dragging: isDragging && draggedWordId === word.id,\n        untimed: word.startTime === 0 && word.endTime === 0\n      }\" :style=\"getWordCarStyle(word)\" @mousedown=\"handleWordMouseDown(word, $event)\">\n        <!-- Word text -->\n        <div class=\"word-text\">{{ word.text }}</div>\n\n        <!-- Hot spots for interaction -->\n        <div class=\"hotspot hotspot-move\" title=\"Drag to move word\" @mousedown.stop=\"startDrag('move', word, $event)\">\n        </div>\n        <div class=\"hotspot hotspot-resize-end\" title=\"Drag to adjust end time\"\n          @mousedown.stop=\"startDrag('resize', word, $event)\"></div>\n\n        <!-- Syllable dividers for multi-syllable words -->\n        <template v-if=\"word.syllables && word.syllables.length > 1\">\n          <div v-for=\"(syllable, index) in word.syllables.slice(0, -1)\" :key=\"`syllable-${index}`\"\n            class=\"hotspot hotspot-syllable-divider\" :style=\"getSyllableDividerStyle(word, index)\"\n            :title=\"`Adjust syllable ${index + 1}/${index + 2} boundary`\"\n            @mousedown.stop=\"startDrag('syllable', word, $event, index)\"></div>\n        </template>\n      </div>\n    </div>\n\n    <!-- Debug panel -->\n    <div v-if=\"showDebug\" class=\"debug-panel\">\n      <h4>Word Timing Editor Debug</h4>\n      <p>Timeline Duration: {{ duration.toFixed(2) }}s</p>\n      <p>\n        View Window: {{ props.viewStart.toFixed(2) }}s - {{ effectiveViewEnd.toFixed(2) }}s ({{ viewDuration.toFixed(2)\n        }}s span)\n      </p>\n      <p>Pixels/Second: {{ pixelsPerSecond.toFixed(1) }}</p>\n      <p>Track Width: {{ trackWidth }}px</p>\n      <p>Total Words: {{ props.words.length }} | Visible: {{ visibleWords.length }}</p>\n      <p>Selected Word: {{ selectedWordId || 'None' }}</p>\n      <p>Drag State: {{ isDragging ? `${dragType} on ${draggedWordId}` : 'None' }}</p>\n      <p v-if=\"isDragging\">Drag Start Time: {{ dragStartTime.toFixed(3) }}s</p>\n      <div v-if=\"selectedWordId\" class=\"selected-word-debug\">\n        <strong>Selected Word Details:</strong>\n        <div class=\"word-timing-summary\">\n          <p v-if=\"visibleWords.find(w => w.id === selectedWordId)\" class=\"timing-info\">\n            Word: \"{{visibleWords.find(w => w.id === selectedWordId)?.text}}\" | Start:\n            {{visibleWords.find(w => w.id === selectedWordId)?.startTime.toFixed(3)}}s | Duration:\n            {{getWordDuration(visibleWords.find(w => w.id === selectedWordId)!).toFixed(3)}}s\n          </p>\n          <div v-if=\"visibleWords.find(w => w.id === selectedWordId)?.syllables\" class=\"syllable-durations\">\n            <strong>Syllable Durations:</strong>\n            <div v-for=\"(syllable, index) in visibleWords.find(w => w.id === selectedWordId)?.syllables\" :key=\"index\"\n              class=\"syllable-info\">\n              \"{{ syllable.text }}\": {{ getSyllableDuration(syllable).toFixed(3) }}s ({{\n                (\n                  (getSyllableDuration(syllable) / getWordDuration(visibleWords.find(w => w.id === selectedWordId)!)) *\n                  100\n                ).toFixed(1)\n              }}%)\n            </div>\n          </div>\n        </div>\n        <details>\n          <summary>Raw JSON Data</summary>\n          <pre>{{\n            JSON.stringify(\n              visibleWords.find(w => w.id === selectedWordId),\n              null,\n              2\n            )\n          }}</pre>\n        </details>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'\nimport { TIMING } from '@/models/TimingConstants'\n\ninterface Syllable {\n  text: string\n  startTime: number\n  endTime: number\n  // Note: We'll calculate duration as endTime - startTime when needed\n}\n\ninterface Word {\n  id: string\n  text: string\n  startTime: number\n  endTime: number // Keep for compatibility, but think in terms of startTime + duration\n  syllables?: Syllable[]\n  // Internal: We'll work with duration = endTime - startTime\n}\n\ninterface Props {\n  words: Word[]\n  duration: number\n  viewStart?: number\n  viewEnd?: number\n  showDebug?: boolean\n  showBackground?: boolean\n  showBorder?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  viewStart: 0,\n  viewEnd: undefined,\n  showDebug: false,\n  showBackground: false,\n  showBorder: false,\n})\n\n// console.log('🔧 WordTimingEditor props received:', {\n//   words: props.words.length,\n//   duration: props.duration,\n//   viewStart: props.viewStart,\n//   viewEnd: props.viewEnd,\n//   showDebug: props.showDebug\n// })\n\nconst emit = defineEmits<{\n  'update:words': [words: Word[]]\n  'select-word': [wordId: string | null]\n}>()\n\n// Refs\nconst timelineTrack = ref<HTMLElement>()\nconst selectedWordId = ref<string | null>(null)\n\n// Drag state\nconst isDragging = ref(false)\nconst draggedWordId = ref<string | null>(null)\nconst dragType = ref<'move' | 'resize' | 'syllable'>('move')\nconst dragStartX = ref(0)\nconst dragStartTime = ref(0)\nconst dragSyllableIndex = ref(0)\n\n// Timeline calculations\nconst trackWidth = ref(800) // Will be updated on mount\nconst effectiveViewEnd = computed(() => props.viewEnd || props.duration)\nconst viewDuration = computed(() => effectiveViewEnd.value - props.viewStart)\nconst pixelsPerSecond = computed(() => trackWidth.value / viewDuration.value)\n\n// Visible words - Strict to show only word fully within viewport\nconst visibleWords = computed(() => {\n  const buffer = 0.02 // No buffer - words appear/disappear exactly at viewport edges\n\n  // console.log('👁️ Calculating visibleWords:', {\n  //   totalWords: props.words.length,\n  //   viewStart: props.viewStart,\n  //   viewEnd: effectiveViewEnd.value,\n  //   duration: props.duration,\n  //   firstFewWords: props.words.slice(0, 3).map(w => ({\n  //     text: w.text,\n  //     startTime: w.startTime,\n  //     endTime: w.endTime,\n  //     isUntimed: w.startTime === 0 && w.endTime === 0\n  //   }))\n  // })\n\n  const filtered = props.words.filter(word => {\n    // Skip words with no timing (startTime and endTime both 0) - they clutter the interface\n    const isUntimed = word.startTime === 0 && word.endTime === 0\n    if (isUntimed) {\n      // console.log('👁️ Skipping untimed word:', word.text)\n      return false // Hide untimed words\n    }\n\n    // For words with timing, check if they're COMPLETELY within the visible time range\n    // Only show words where BOTH start and end are within the viewport\n    // This prevents visual issues where partial words \"stick\" at viewport edges\n    const wordStart = word.startTime\n    const wordEnd = word.endTime\n    const viewWindowStart = props.viewStart - buffer\n    const viewWindowEnd = effectiveViewEnd.value + buffer\n\n    // A word is visible only if it's completely contained in the viewport\n    const inRange = wordStart >= viewWindowStart && wordEnd <= viewWindowEnd\n\n    // console.log('👁️ Word range check:', {\n    //   text: word.text,\n    //   wordStart,\n    //   wordEnd,\n    //   viewWindowStart,\n    //   viewWindowEnd,\n    //   inRange,\n    //   viewStart: props.viewStart,\n    //   viewEnd: effectiveViewEnd.value\n    // })\n\n    return inRange\n  })\n\n  // console.log('👁️ Visible words result:', {\n  //   visible: filtered.length,\n  //   words: filtered.map(w => w.text)\n  // })\n\n  return filtered\n})\n\n// Convert time to pixels with proper bounds checking\nconst timeToPixels = (time: number): number => {\n  const relativeTime = time - props.viewStart\n  return relativeTime * pixelsPerSecond.value\n}\n\n// Convert pixels to time with proper bounds checking\n// const pixelsToTime = (pixels: number): number => {\n//   return props.viewStart + pixels / pixelsPerSecond.value\n// }\n\n// Get CSS style for word car positioning with bounds checking\nconst getWordCarStyle = (word: Word) => {\n  // Special handling for untimed words (both startTime and endTime are 0)\n  if (word.startTime === 0 && word.endTime === 0) {\n    // Position untimed words sequentially at the beginning\n    const untimedWords = props.words.filter(w => w.startTime === 0 && w.endTime === 0)\n    const wordIndex = untimedWords.findIndex(w => w.id === word.id)\n    const wordWidth = Math.max(word.text.length * 8 + 20, 60) // Width based on text length, minimum 60px\n    const leftPosition = wordIndex * (wordWidth + 5) // 5px gap between untimed words\n\n    return {\n      left: `${leftPosition}px`,\n      width: `${wordWidth}px`,\n    }\n  }\n\n  // Normal handling for timed words\n  const startPixels = timeToPixels(word.startTime)\n  const endPixels = timeToPixels(word.endTime)\n  const width = endPixels - startPixels\n\n  // Ensure minimum width and proper positioning\n  const safeLeft = Math.max(0, startPixels)\n  const safeWidth = Math.max(width, 24) // Minimum 24px for usable hotspots\n\n  // Clamp to track bounds but allow slight overflow for edge cases\n  const maxLeft = trackWidth.value - 24\n  const finalLeft = Math.min(safeLeft, maxLeft)\n  const finalWidth = Math.min(safeWidth, trackWidth.value - finalLeft)\n\n  return {\n    left: `${finalLeft}px`,\n    width: `${finalWidth}px`,\n  }\n}\n\n// Get CSS style for syllable divider positioning with bounds checking\nconst getSyllableDividerStyle = (word: Word, syllableIndex: number) => {\n  if (!word.syllables || syllableIndex >= word.syllables.length - 1) return { display: 'none' }\n\n  const wordStartPixels = timeToPixels(word.startTime)\n  const syllableEndPixels = timeToPixels(word.syllables[syllableIndex].endTime)\n  const wordWidth = timeToPixels(word.endTime) - wordStartPixels\n\n  // Calculate position relative to word start, with bounds checking\n  const relativePosition = syllableEndPixels - wordStartPixels\n  const safePosition = Math.max(6, Math.min(relativePosition, wordWidth - 6)) // Keep within word bounds\n\n  return {\n    left: `${safePosition}px`,\n    display: wordWidth > 20 ? 'block' : 'none', // Hide dividers in very narrow words\n  }\n}\n\n// Mouse event handlers\nconst handleWordMouseDown = (word: Word, event: MouseEvent) => {\n  event.preventDefault()\n  selectedWordId.value = word.id\n  emit('select-word', word.id)\n}\n\n// Store original syllable proportions for move operations\nconst originalSyllableProportions = ref<{ [wordId: string]: number[] }>({})\n\n// Duration-based helper functions for more natural workflow\nconst getWordDuration = (word: Word): number => Math.max(TIMING.word.minDuration / 1000, word.endTime - word.startTime)\nconst getSyllableDuration = (syllable: Syllable): number => syllable.endTime - syllable.startTime\n\n// Validate and fix word timing to prevent negative durations\nconst validateWordTiming = (word: Word): Word => {\n  if (word.endTime <= word.startTime) {\n    const minEndTime = word.startTime + TIMING.word.minDuration / 1000\n    return {\n      ...word,\n      endTime: minEndTime\n    }\n  }\n  return word\n}\n\nconst setWordDuration = (word: Word, newDuration: number): Word => ({\n  ...word,\n  endTime: word.startTime + newDuration,\n})\n\nconst moveWord = (word: Word, newStartTime: number): Word => {\n  const duration = getWordDuration(word)\n  return {\n    ...word,\n    startTime: newStartTime,\n    endTime: newStartTime + duration,\n  }\n}\n\nconst startDrag = (type: 'move' | 'resize' | 'syllable', word: Word, event: MouseEvent, syllableIndex?: number) => {\n  event.preventDefault()\n  event.stopPropagation()\n\n  isDragging.value = true\n  draggedWordId.value = word.id\n  dragType.value = type\n  dragStartX.value = event.clientX\n  // Set drag start time based on operation type\n  if (type === 'move') {\n    dragStartTime.value = word.startTime\n  } else if (type === 'resize') {\n    dragStartTime.value = word.endTime\n  } else if (type === 'syllable' && typeof syllableIndex === 'number' && word.syllables) {\n    dragStartTime.value = word.syllables[syllableIndex].endTime\n    dragSyllableIndex.value = syllableIndex\n    console.log(`🎯 Starting syllable drag: word=\"${word.text}\", syllable=${syllableIndex}, boundary=${dragStartTime.value.toFixed(3)}s`)\n  }\n\n  // Store original syllable proportions for this word (duration-based)\n  if (word.syllables && word.syllables.length > 1) {\n    const wordDuration = getWordDuration(word)\n    originalSyllableProportions.value[word.id] = word.syllables.map(syllable => getSyllableDuration(syllable) / wordDuration)\n  }\n\n  selectedWordId.value = word.id\n  emit('select-word', word.id)\n\n  // Add global mouse event listeners\n  document.addEventListener('mousemove', handleMouseMove)\n  document.addEventListener('mouseup', handleMouseUp)\n\n  // Add visual feedback\n  document.body.style.cursor = type === 'move' ? 'grabbing' : 'col-resize'\n  document.body.style.userSelect = 'none'\n}\n\nconst handleMouseMove = (event: MouseEvent) => {\n  if (!isDragging.value || !draggedWordId.value) return\n\n  const deltaX = event.clientX - dragStartX.value\n  const deltaTime = deltaX / pixelsPerSecond.value\n\n  const wordIndex = props.words.findIndex(w => w.id === draggedWordId.value)\n  if (wordIndex === -1) return\n\n  const updatedWords = [...props.words]\n  const word = { ...updatedWords[wordIndex] }\n\n  // Get neighboring words for collision detection\n  const previousWord = wordIndex > 0 ? props.words[wordIndex - 1] : null\n  const nextWord = wordIndex < props.words.length - 1 ? props.words[wordIndex + 1] : null\n\n  if (dragType.value === 'move') {\n    // Move entire word - duration stays the same, only start time changes\n    const wordDuration = getWordDuration(word)\n    let newStartTime = Math.max(0, dragStartTime.value + deltaTime)\n\n    // Debug: log original and calculated values\n    console.log(`🔧 Moving \"${word.text}\": original=${word.startTime}-${word.endTime} (${wordDuration}s), newStart=${newStartTime}`)\n\n    // Smart collision detection - allow swapping when words are overlapped\n    const isMovingLeft = newStartTime < word.startTime\n    const isMovingRight = newStartTime > word.startTime\n\n    // Check if we're trying to move past an overlapped word\n    const isPreviousOverlapped = previousWord && previousWord.endTime > word.startTime\n    const isNextOverlapped = nextWord && nextWord.startTime < word.endTime\n\n    console.log(`🔧 Collision check: movingLeft=${isMovingLeft}, movingRight=${isMovingRight}, prevOverlapped=${isPreviousOverlapped}, nextOverlapped=${isNextOverlapped}`)\n\n    // Apply constraints, but allow swapping past overlapped words\n    if (previousWord && !isPreviousOverlapped) {\n      // Normal case: prevent overlap with non-overlapped previous word\n      newStartTime = Math.max(newStartTime, previousWord.endTime + TIMING.word.collisionMargin / 1000)\n    } else if (previousWord && isPreviousOverlapped && isMovingLeft) {\n      // Allow moving left past overlapped previous word, but not too far\n      const minStartTime = Math.max(0, previousWord.startTime - wordDuration - TIMING.word.collisionMargin / 1000)\n      newStartTime = Math.max(newStartTime, minStartTime)\n    }\n\n    if (nextWord && !isNextOverlapped) {\n      // Normal case: prevent overlap with non-overlapped next word\n      const maxStartTime = nextWord.startTime - wordDuration - TIMING.word.collisionMargin / 1000\n      newStartTime = Math.min(newStartTime, maxStartTime)\n    } else if (nextWord && isNextOverlapped && isMovingRight) {\n      // Allow moving right past overlapped next word, but not too far\n      const maxStartTime = nextWord.endTime + TIMING.word.collisionMargin / 1000\n      newStartTime = Math.min(newStartTime, maxStartTime)\n    }\n\n    // Also constrain to view window to prevent disappearing\n    const viewportBuffer = TIMING.editor.viewportBuffer / 1000\n    const maxViewStartTime = effectiveViewEnd.value - wordDuration - viewportBuffer\n    newStartTime = Math.min(newStartTime, maxViewStartTime)\n    newStartTime = Math.max(newStartTime, props.viewStart - viewportBuffer)\n\n    // Apply the move (preserving duration)\n    const movedWord = moveWord(word, newStartTime)\n    console.log(`🔧 After moveWord: ${movedWord.startTime}-${movedWord.endTime}`)\n\n    word.startTime = movedWord.startTime\n    word.endTime = movedWord.endTime\n\n    // Update syllable timings using stored proportions (preserving their durations)\n    if (word.syllables && originalSyllableProportions.value[word.id]) {\n      const proportions = originalSyllableProportions.value[word.id]\n      let syllableStartTime = newStartTime\n\n      word.syllables = word.syllables.map((syllable, index) => {\n        const syllableDuration = proportions[index] * wordDuration\n        const result = {\n          ...syllable,\n          startTime: syllableStartTime,\n          endTime: syllableStartTime + syllableDuration,\n        }\n        syllableStartTime += syllableDuration\n        return result\n      })\n    }\n  } else if (dragType.value === 'resize') {\n    // Resize duration - drag the end time directly\n    let newEndTime = Math.max(word.startTime + TIMING.word.minDuration / 1000, dragStartTime.value + deltaTime)\n    let newDuration = newEndTime - word.startTime\n\n    // Constrain resize to not overlap with next word\n    if (nextWord) {\n      const maxDuration = nextWord.startTime - word.startTime - TIMING.word.collisionMargin / 1000\n      newDuration = Math.min(newDuration, maxDuration)\n      newEndTime = word.startTime + newDuration\n    }\n\n    // Constrain to reasonable view bounds\n    const maxEndTime = effectiveViewEnd.value + TIMING.editor.viewportBuffer / 1000\n    if (newEndTime > maxEndTime) {\n      newDuration = maxEndTime - word.startTime\n      newEndTime = maxEndTime\n    }\n\n    // Apply the new duration\n    const resizedWord = setWordDuration(word, newDuration)\n    word.endTime = resizedWord.endTime\n\n    // DON'T redistribute syllables - keep them at absolute positions (like test rig)\n    // User has carefully placed s-breaks and they should not move during word resize\n    // if (word.syllables && word.syllables.length > 1) {\n    //   word.syllables = distributeSyllableTiming(word, newDuration, word.syllables.length)\n    // }\n  } else if (dragType.value === 'syllable') {\n    // Adjust syllable boundary\n    if (word.syllables && dragSyllableIndex.value < word.syllables.length - 1) {\n      const syllableMargin = TIMING.syllable.minDuration / 1000 / 2 // Half of min duration in seconds for boundary adjustment\n      const newBoundaryTime = Math.max(\n        word.syllables[dragSyllableIndex.value].startTime + syllableMargin,\n        Math.min(word.syllables[dragSyllableIndex.value + 1].endTime - syllableMargin, dragStartTime.value + deltaTime)\n      )\n\n      // Debug logging for syllable boundary adjustment\n      console.log(`🔧 Syllable boundary: \"${word.syllables[dragSyllableIndex.value].text}\" | \"${word.syllables[dragSyllableIndex.value + 1].text}\" → ${newBoundaryTime.toFixed(3)}s`)\n\n      word.syllables[dragSyllableIndex.value].endTime = newBoundaryTime\n      word.syllables[dragSyllableIndex.value + 1].startTime = newBoundaryTime\n    }\n  }\n\n  // Validate and fix word timing before updating\n  const validatedWord = validateWordTiming(word)\n\n  updatedWords[wordIndex] = validatedWord\n\n  // Emit immediately so parent gets syllable changes for s-break drags\n  // Performance is now acceptable with direct syllable updates (no RelativeSyllableTiming recalc)\n  const validatedWords = updatedWords.map(validateWordTiming)\n  emit('update:words', validatedWords)\n}\n\nconst handleMouseUp = () => {\n  // Clear stored proportions for completed drag\n  if (draggedWordId.value && originalSyllableProportions.value[draggedWordId.value]) {\n    delete originalSyllableProportions.value[draggedWordId.value]\n  }\n\n  isDragging.value = false\n  draggedWordId.value = null\n\n  // Remove global listeners\n  document.removeEventListener('mousemove', handleMouseMove)\n  document.removeEventListener('mouseup', handleMouseUp)\n\n  // Reset cursor\n  document.body.style.cursor = ''\n  document.body.style.userSelect = ''\n}\n\n// Smart syllable timing distribution (musical pattern: shorter first, longer last)\n// const distributeSyllableTiming = (word: Word, totalDuration: number, syllableCount: number): Syllable[] => {\n//   if (!word.syllables || syllableCount <= 1) return word.syllables || []\n\n//   // Use centralized syllable weighting system\n//   const weights = TimingUtils.calculateSyllableWeights(syllableCount)\n\n//   const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n//   const syllableDurations = weights.map(weight => (weight / totalWeight) * totalDuration)\n\n//   let currentTime = word.startTime\n//   return word.syllables\n//     .map((syllable, index) => ({\n//       ...syllable,\n//       startTime: currentTime,\n//       endTime: currentTime + syllableDurations[index],\n//     }))\n//     .map((syllable, index, array) => {\n//       currentTime = syllable.endTime\n//       // Ensure last syllable ends exactly at word end\n//       if (index === array.length - 1) {\n//         syllable.endTime = word.endTime\n//       }\n//       return syllable\n//     })\n// }\n\n// Setup timeline width on mount\nonMounted(async () => {\n  await nextTick() // Wait for DOM to be fully rendered\n\n  const updateTrackWidth = () => {\n    if (timelineTrack.value) {\n      const newWidth = timelineTrack.value.clientWidth\n      if (newWidth > 0) {\n        trackWidth.value = newWidth\n        // console.log('📏 Track width updated:', newWidth)\n      }\n    }\n  }\n\n  updateTrackWidth()\n\n  // Also update after another tick in case the parent container is still sizing\n  setTimeout(updateTrackWidth, 100)\n\n  window.addEventListener('resize', updateTrackWidth)\n\n  onUnmounted(() => {\n    window.removeEventListener('resize', updateTrackWidth)\n  })\n})\n\n// Watch for changes that might affect layout\nwatch([() => props.viewStart, () => props.viewEnd, () => props.duration], () => {\n  // console.log('🔄 WordTimingEditor props changed:', {\n  //   viewStart: {\n  //     old: oldValues?.[0], new: newValues[0]\n  //   },\n  //   viewEnd: {\n  //     old: oldValues?.[1], new: newValues[1]\n  //   },\n  //   duration: {\n  //     old: oldValues?.[2], new: newValues[2]\n  //   }\n  // })\n\n  // Update track width when view parameters change\n  nextTick(() => {\n    if (timelineTrack.value) {\n      const newWidth = timelineTrack.value.clientWidth\n      if (newWidth > 0 && newWidth !== trackWidth.value) {\n        trackWidth.value = newWidth\n        // console.log('📏 Track width updated (via watcher):', newWidth)\n      }\n    }\n  })\n}, { flush: 'post' })\n\n// Cleanup on unmount\nonUnmounted(() => {\n  document.removeEventListener('mousemove', handleMouseMove)\n  document.removeEventListener('mouseup', handleMouseUp)\n})\n</script>\n\n<style scoped>\n.word-timing-editor {\n  width: 100%;\n  margin: 5px 0px;\n  padding: 0px 4px\n}\n\n.timeline-track {\n  position: relative;\n  height: 40px;\n  overflow: hidden;\n}\n\n/* Optional background styling */\n.timeline-track.with-background {\n  background: linear-gradient(to bottom, #fafafa 0%, #f0f0f0 100%);\n  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n/* Optional border styling */\n.timeline-track.with-border {\n  border: 1px solid #c4c4c4;\n  border-radius: 6px;\n}\n\n/* The 1px black horizontal line (train track) */\n.timeline-baseline {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  height: 1px;\n  background: #bbbbbb;\n  z-index: 1;\n}\n\n/* Word boxes (train cars) */\n.word-car {\n  position: absolute;\n  top: 50%;\n  height: 28px;\n  transform: translateY(-50%);\n  background: #e3f2fd;\n  border: 1px solid #1976d2;\n  border-radius: 3px;\n  cursor: grab;\n  z-index: 10;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.1s ease;\n}\n\n.word-car:hover {\n  background: #bbdefb;\n  border-color: #1565c0;\n  z-index: 15;\n}\n\n.word-car:hover .word-text {\n  color: #0a3a7a;\n  text-shadow: 0 1px 2px rgba(255, 255, 255, 1);\n}\n\n.word-car.untimed {\n  background: #fff8e1;\n  border: 2px dashed #ff8f00;\n  border-color: #ff8f00;\n  opacity: 0.8;\n}\n\n.word-car.untimed:hover {\n  background: #fff3e0;\n  opacity: 1;\n  border-style: solid;\n}\n\n.word-car.selected {\n  background: #fff3e0;\n  border-color: #f57c00;\n  box-shadow: 0 0 0 2px rgba(245, 124, 0, 0.4);\n  z-index: 20;\n}\n\n.word-car.selected .word-text {\n  color: #bf360c;\n  font-weight: 600;\n  text-shadow: none;\n}\n\n.word-car.dragging {\n  cursor: grabbing;\n  z-index: 25;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  background: #fff8e1;\n  border-color: #ff8f00;\n}\n\n.word-car.dragging .word-text {\n  color: #ef6c00;\n  text-shadow: 0 1px 3px rgba(255, 255, 255, 1);\n}\n\n.word-text {\n  color: #0d47a1;\n  font-size: 11px;\n  font-weight: 700;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  pointer-events: none;\n  padding: 0 6px;\n  text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);\n}\n\n/* Hot spots for interaction */\n.hotspot {\n  position: absolute;\n  background: rgba(255, 255, 255, 0.7);\n  border-radius: 2px;\n  z-index: 30;\n}\n\n.hotspot-move {\n  top: 2px;\n  left: 2px;\n  right: 2px;\n  bottom: 2px;\n  cursor: grab;\n}\n\n.hotspot-move:hover {\n  background: rgba(255, 255, 255, 0.9);\n}\n\n.hotspot-resize-end {\n  top: -2px;\n  right: -4px;\n  width: 8px;\n  height: calc(100% + 4px);\n  cursor: col-resize;\n  background: rgba(76, 175, 80, 0.8);\n  border-radius: 0 3px 3px 0;\n  border: 1px solid rgba(76, 175, 80, 1);\n}\n\n.hotspot-resize-end:hover {\n  background: rgba(76, 175, 80, 1);\n  width: 10px;\n  right: -5px;\n  box-shadow: 0 0 4px rgba(76, 175, 80, 0.6);\n}\n\n.hotspot-syllable-divider {\n  top: -2px;\n  width: 6px;\n  height: calc(100% + 4px);\n  cursor: col-resize;\n  background: rgba(255, 152, 0, 0.8);\n  transform: translateX(-3px);\n  border-radius: 2px;\n  border: 1px solid rgba(255, 152, 0, 1);\n}\n\n.hotspot-syllable-divider:hover {\n  background: rgba(255, 152, 0, 1);\n  width: 8px;\n  transform: translateX(-4px);\n  box-shadow: 0 0 4px rgba(255, 152, 0, 0.6);\n}\n\n/* Debug panel */\n.debug-panel {\n  margin-top: 10px;\n  padding: 12px;\n  background: #f8f9fa;\n  border: 1px solid #dee2e6;\n  border-radius: 4px;\n  font-size: 12px;\n  font-family: 'Courier New', monospace;\n}\n\n.debug-panel h4 {\n  margin: 0 0 8px 0;\n  font-size: 14px;\n  font-family: inherit;\n}\n\n.debug-panel p {\n  margin: 2px 0;\n  line-height: 1.4;\n}\n\n.selected-word-debug {\n  margin-top: 8px;\n  padding: 8px;\n  background: #e9ecef;\n  border-radius: 3px;\n  max-height: 200px;\n  overflow-y: auto;\n}\n\n.selected-word-debug pre {\n  margin: 4px 0 0 0;\n  font-size: 10px;\n  line-height: 1.2;\n}\n\n.word-timing-summary {\n  font-family: 'Courier New', monospace;\n  font-size: 11px;\n}\n\n.timing-info {\n  background: #d1ecf1;\n  padding: 4px 6px;\n  border-radius: 3px;\n  margin: 4px 0;\n  border-left: 3px solid #0c5460;\n}\n\n.syllable-durations {\n  margin-top: 6px;\n}\n\n.syllable-info {\n  padding: 2px 4px;\n  margin: 1px 0;\n  background: #fff3cd;\n  border-radius: 2px;\n  font-size: 10px;\n}\n\ndetails {\n  margin-top: 8px;\n}\n\nsummary {\n  cursor: pointer;\n  font-size: 10px;\n  color: #6c757d;\n}\n</style>\n"],"names":["RelativeSyllableTiming","wordData","__publicField","currentOffset","syllable","offsetError","TIMING","expectedWordDuration","actualSyllablesTotalDuration","newStartTime","duration","newEndTime","newWordDuration","syllables","lastIndex","lastSyllableStartOffset","newLastSyllableDuration","oldFirstDuration","newFirstDuration","deltaOffset","i","syllableIndex","absoluteNewEndTime","currentSyllable","nextSyllable","newCurrentDuration","nextSyllableEndOffset","wordId","wordText","wordStartTime","wordEndTime","absoluteSyllables","cleanedSyllables","currentTime","isLast","startTime","endTime","minDuration","relativeSyllables","expectedOffset","safeDuration","actualWordDuration","sum","syl","adjustedWordEndTime","originalWordDuration","wordStartSeconds","wordEndSeconds","syllableTexts","lastSyllableWeight","wordDuration","baseSyllableDuration","remainder","text","index","weights","_","totalWeight","weight","totalAssigned","props","__props","emit","__emit","timelineTrack","ref","selectedWordId","isDragging","draggedWordId","dragType","dragStartX","dragStartTime","dragSyllableIndex","trackWidth","effectiveViewEnd","computed","viewDuration","pixelsPerSecond","visibleWords","word","wordStart","wordEnd","viewWindowStart","viewWindowEnd","timeToPixels","time","getWordCarStyle","wordIndex","w","wordWidth","leftPosition","startPixels","width","safeLeft","safeWidth","maxLeft","finalLeft","finalWidth","getSyllableDividerStyle","wordStartPixels","syllableEndPixels","relativePosition","safePosition","handleWordMouseDown","event","originalSyllableProportions","getWordDuration","getSyllableDuration","validateWordTiming","minEndTime","setWordDuration","newDuration","moveWord","startDrag","type","handleMouseMove","handleMouseUp","deltaTime","updatedWords","previousWord","nextWord","isMovingLeft","isMovingRight","isPreviousOverlapped","isNextOverlapped","minStartTime","maxStartTime","viewportBuffer","maxViewStartTime","movedWord","proportions","syllableStartTime","syllableDuration","result","maxDuration","maxEndTime","resizedWord","syllableMargin","newBoundaryTime","validatedWord","validatedWords","onMounted","nextTick","updateTrackWidth","newWidth","onUnmounted","watch","_openBlock","_createElementBlock","_hoisted_1","_createElementVNode","_Fragment","_renderList","_normalizeStyle","$event","_hoisted_3","_toDisplayString","_withModifiers","_hoisted_7","_cache","_hoisted_9","_hoisted_10","_hoisted_11","_a","_b","_c","_hoisted_12","_d"],"mappings":"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"}