{"version":3,"file":"WordTimingEditor-legacy-6e8be2c8.js","sources":["../../src/models/RelativeSyllableTiming.ts","../../src/components/WordTimingEditor.vue"],"sourcesContent":["import { TIMING } from '@/models/TimingConstants'\n\n/**\n * RelativeSyllableTiming - A proper TypeScript model for handling syllable timing\n *\n * Key Design Principles:\n * 1. Syllables are stored as relative offsets/durations from word start\n * 2. Word movement automatically moves all syllables (no manual sync needed)\n * 3. Word resizing only affects the last syllable\n * 4. Conversion methods handle absolute time calculations for UI display\n */\n\nexport interface RelativeSyllable {\n  text: string\n  startOffset: number  // Offset from word start (milliseconds)\n  duration: number     // Syllable duration (milliseconds)\n}\n\nexport interface AbsoluteSyllable {\n  text: string\n  startTime: number    // Absolute start time (milliseconds)\n  endTime: number      // Absolute end time (milliseconds)\n}\n\nexport interface TimedWordData {\n  id: string\n  text: string\n  startTime: number    // Milliseconds\n  endTime: number      // Milliseconds\n  syllables: RelativeSyllable[]\n}\n\nexport class RelativeSyllableTiming {\n  private word: TimedWordData\n\n  constructor(wordData: TimedWordData) {\n    this.word = { ...wordData }\n    this.validateSyllables()\n  }\n\n  /**\n   * Validate that syllables are properly structured\n   */\n  private validateSyllables(): void {\n    if (this.word.syllables.length === 0) {\n      throw new Error('Word must have at least one syllable')\n    }\n\n    let currentOffset = 0\n    for (const syllable of this.word.syllables) {\n      // Allow small rounding errors in offset alignment\n      const offsetError = Math.abs(syllable.startOffset - currentOffset)\n      if (offsetError > TIMING.validation.timingPrecision) {\n        throw new Error(`Syllable \"${syllable.text}\" has gap or overlap. Expected startOffset: ${currentOffset}, got: ${syllable.startOffset} (error: ${offsetError}ms)`)\n      }\n      if (syllable.duration <= 0) {\n        throw new Error(`Syllable \"${syllable.text}\" must have positive duration, got: ${syllable.duration}`)\n      }\n      currentOffset += syllable.duration\n    }\n\n    const expectedWordDuration = this.word.endTime - this.word.startTime\n    const actualSyllablesTotalDuration = currentOffset\n    if (Math.abs(expectedWordDuration - actualSyllablesTotalDuration) > TIMING.validation.durationTolerance) {\n      throw new Error(`Word duration (${expectedWordDuration}ms) doesn't match total syllable duration (${actualSyllablesTotalDuration}ms)`)\n    }\n  }\n\n  /**\n   * Get word data (immutable copy)\n   */\n  getWordData(): Readonly<TimedWordData> {\n    return { ...this.word }\n  }\n\n  /**\n   * Get word duration\n   */\n  getWordDuration(): number {\n    return this.word.endTime - this.word.startTime\n  }\n\n  /**\n   * Convert relative syllables to absolute positions for UI display\n   */\n  getAbsoluteSyllables(): AbsoluteSyllable[] {\n    return this.word.syllables.map(syllable => ({\n      text: syllable.text,\n      startTime: this.word.startTime + syllable.startOffset,\n      endTime: this.word.startTime + syllable.startOffset + syllable.duration\n    }))\n  }\n\n  /**\n   * Move word to new start time - syllables automatically follow\n   */\n  moveWord(newStartTime: number): RelativeSyllableTiming {\n    const duration = this.getWordDuration()\n    return new RelativeSyllableTiming({\n      ...this.word,\n      startTime: newStartTime,\n      endTime: newStartTime + duration\n    })\n  }\n\n  /**\n   * Resize word by changing end time - only affects last syllable\n   */\n  resizeWordEnd(newEndTime: number): RelativeSyllableTiming {\n    if (newEndTime <= this.word.startTime) {\n      throw new Error('Word end time must be after start time')\n    }\n\n    const newWordDuration = newEndTime - this.word.startTime\n    const syllables = [...this.word.syllables]\n\n    if (syllables.length === 1) {\n      // Single syllable: adjust its duration\n      syllables[0] = {\n        ...syllables[0],\n        duration: newWordDuration\n      }\n    } else {\n      // Multi-syllable: only adjust last syllable duration\n      const lastIndex = syllables.length - 1\n      const lastSyllableStartOffset = syllables[lastIndex].startOffset\n      const newLastSyllableDuration = newWordDuration - lastSyllableStartOffset\n\n      if (newLastSyllableDuration <= 1) { // 1ms minimum duration\n        throw new Error('Resizing would make last syllable have zero or negative duration')\n      }\n\n      syllables[lastIndex] = {\n        ...syllables[lastIndex],\n        duration: newLastSyllableDuration\n      }\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      endTime: newEndTime,\n      syllables\n    })\n  }\n\n  /**\n   * Resize word by changing start time - only affects first syllable\n   */\n  resizeWordStart(newStartTime: number): RelativeSyllableTiming {\n    if (newStartTime >= this.word.endTime) {\n      throw new Error('Word start time must be before end time')\n    }\n\n    const newWordDuration = this.word.endTime - newStartTime\n    const syllables = [...this.word.syllables]\n\n    if (syllables.length === 1) {\n      // Single syllable: adjust its duration and reset offset to 0\n      syllables[0] = {\n        ...syllables[0],\n        startOffset: 0,\n        duration: newWordDuration\n      }\n    } else {\n      // Multi-syllable: adjust first syllable duration, shift others\n      const oldFirstDuration = syllables[0].duration\n      const newFirstDuration = newWordDuration - (this.getWordDuration() - oldFirstDuration)\n\n      if (newFirstDuration <= 1) { // 1ms minimum duration\n        throw new Error('Resizing would make first syllable have zero or negative duration')\n      }\n\n      const deltaOffset = oldFirstDuration - newFirstDuration\n\n      // Adjust first syllable\n      syllables[0] = {\n        ...syllables[0],\n        startOffset: 0,\n        duration: newFirstDuration\n      }\n\n      // Shift all other syllables\n      for (let i = 1; i < syllables.length; i++) {\n        syllables[i] = {\n          ...syllables[i],\n          startOffset: syllables[i].startOffset - deltaOffset\n        }\n      }\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      startTime: newStartTime,\n      syllables\n    })\n  }\n\n  /**\n   * Move and resize word in one operation\n   */\n  moveAndResize(newStartTime: number, newEndTime: number): RelativeSyllableTiming {\n    if (newStartTime >= newEndTime) {\n      throw new Error('Word start time must be before end time')\n    }\n\n    // First move, then resize\n    return this.moveWord(newStartTime).resizeWordEnd(newEndTime)\n  }\n\n  /**\n   * Adjust individual syllable boundary\n   */\n  adjustSyllableBoundary(syllableIndex: number, newEndTime: number): RelativeSyllableTiming {\n    if (syllableIndex < 0 || syllableIndex >= this.word.syllables.length - 1) {\n      throw new Error('Can only adjust boundaries between syllables')\n    }\n\n    const absoluteNewEndTime = newEndTime - this.word.startTime\n    if (absoluteNewEndTime <= this.word.syllables[syllableIndex].startOffset ||\n      absoluteNewEndTime >= this.word.syllables[syllableIndex + 1].startOffset + this.word.syllables[syllableIndex + 1].duration) {\n      throw new Error('New syllable boundary is outside valid range')\n    }\n\n    const syllables = [...this.word.syllables]\n    const currentSyllable = syllables[syllableIndex]\n    const nextSyllable = syllables[syllableIndex + 1]\n\n    // Adjust current syllable's duration\n    const newCurrentDuration = absoluteNewEndTime - currentSyllable.startOffset\n    syllables[syllableIndex] = {\n      ...currentSyllable,\n      duration: newCurrentDuration\n    }\n\n    // Adjust next syllable's start offset and duration\n    const nextSyllableEndOffset = nextSyllable.startOffset + nextSyllable.duration\n    syllables[syllableIndex + 1] = {\n      ...nextSyllable,\n      startOffset: absoluteNewEndTime,\n      duration: nextSyllableEndOffset - absoluteNewEndTime\n    }\n\n    return new RelativeSyllableTiming({\n      ...this.word,\n      syllables\n    })\n  }\n\n  /**\n   * Create from legacy absolute syllable data (expects milliseconds)\n   * Automatically fixes small gaps/overlaps in syllable timing\n   */\n  static fromAbsoluteSyllables(wordId: string, wordText: string, wordStartTime: number, wordEndTime: number, absoluteSyllables: AbsoluteSyllable[]): RelativeSyllableTiming {\n    if (absoluteSyllables.length === 0) {\n      throw new Error('Must have at least one syllable')\n    }\n\n    // Clean up syllable timing to ensure continuity\n    const cleanedSyllables: AbsoluteSyllable[] = []\n    let currentTime = wordStartTime\n\n    for (let i = 0; i < absoluteSyllables.length; i++) {\n      const syllable = absoluteSyllables[i]\n      const isLast = i === absoluteSyllables.length - 1\n\n      let startTime = Math.round(syllable.startTime)\n      let endTime = Math.round(syllable.endTime)\n\n      // Fix small gaps/overlaps using centralized tolerance\n      if (Math.abs(startTime - currentTime) <= TIMING.validation.gapTolerance) {\n        startTime = currentTime\n      }\n\n      // Ensure positive duration using centralized minimum\n      if (endTime <= startTime) {\n        const minDuration = Math.max(TIMING.validation.timingPrecision, TIMING.syllable.minDuration / 1000)\n        const minEndTime = startTime + minDuration\n        // console.warn(`⚠️ Fixed negative duration for syllable \"${syllable.text}\": was ${startTime}-${endTime}, now ${startTime}-${minEndTime}`)\n        endTime = minEndTime\n      }\n\n      // For last syllable, ensure it ends exactly at word end\n      if (isLast) {\n        endTime = Math.round(wordEndTime)\n      }\n\n      cleanedSyllables.push({\n        text: syllable.text,\n        startTime,\n        endTime\n      })\n\n      currentTime = endTime\n    }\n\n    // Convert to relative syllables with proper offset calculation\n    const relativeSyllables: RelativeSyllable[] = []\n    let expectedOffset = 0\n\n    for (const syllable of cleanedSyllables) {\n      const duration = syllable.endTime - syllable.startTime\n\n      // Ensure minimum duration\n      const safeDuration = Math.max(duration, TIMING.validation.timingPrecision)\n\n      if (duration <= 0) {\n        // console.warn(`⚠️ Fixed zero/negative duration for \"${syllable.text}\": ${duration}ms → ${safeDuration}ms`)\n      }\n\n      relativeSyllables.push({\n        text: syllable.text,\n        startOffset: expectedOffset, // Use expected offset, not calculated\n        duration: safeDuration\n      })\n\n      expectedOffset += safeDuration\n    }\n\n    // Calculate actual word duration from cleaned syllables\n    const actualWordDuration = relativeSyllables.reduce((sum, syl) => sum + syl.duration, 0)\n    const adjustedWordEndTime = Math.round(wordStartTime) + actualWordDuration\n\n    // If word duration changed significantly, log it\n    const originalWordDuration = Math.round(wordEndTime) - Math.round(wordStartTime)\n    if (Math.abs(actualWordDuration - originalWordDuration) > TIMING.validation.durationTolerance) {\n      // console.warn(`⚠️ Adjusted word \"${wordText}\" duration: ${originalWordDuration}ms → ${actualWordDuration}ms to match syllables`)\n    }\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(wordStartTime),\n      endTime: adjustedWordEndTime,\n      syllables: relativeSyllables\n    })\n  }\n\n  /**\n   * Create from UI data (converts seconds to milliseconds)\n   */\n  static fromSecondsData(wordId: string, wordText: string, wordStartSeconds: number, wordEndSeconds: number, syllableTexts: string[], lastSyllableWeight: number = 1.2): RelativeSyllableTiming {\n    const wordStartTime = Math.round(wordStartSeconds * 1000)\n    const wordEndTime = Math.round(wordEndSeconds * 1000)\n    return RelativeSyllableTiming.createWeightedSyllables(wordId, wordText, wordStartTime, wordEndTime, syllableTexts, lastSyllableWeight)\n  }\n\n  /**\n   * Convert to UI data (milliseconds to seconds)\n   */\n  toSecondsData(): { word: { id: string, text: string, startTime: number, endTime: number }, syllables: { text: string, startTime: number, endTime: number }[] } {\n    const absoluteSyllables = this.getAbsoluteSyllables()\n    return {\n      word: {\n        id: this.word.id,\n        text: this.word.text,\n        startTime: this.word.startTime / 1000,\n        endTime: this.word.endTime / 1000\n      },\n      syllables: absoluteSyllables.map(syl => ({\n        text: syl.text,\n        startTime: syl.startTime / 1000,\n        endTime: syl.endTime / 1000\n      }))\n    }\n  }\n\n  /**\n   * Create a simple word with even syllable distribution (expects milliseconds)\n   */\n  static createEvenSyllables(wordId: string, wordText: string, startTime: number, endTime: number, syllableTexts: string[]): RelativeSyllableTiming {\n    const wordDuration = Math.round(endTime - startTime)\n    const baseSyllableDuration = Math.floor(wordDuration / syllableTexts.length)\n    const remainder = wordDuration % syllableTexts.length\n\n    const syllables: RelativeSyllable[] = []\n    let currentOffset = 0\n\n    syllableTexts.forEach((text, index) => {\n      // Distribute remainder across first syllables to ensure exact total\n      const duration = baseSyllableDuration + (index < remainder ? 1 : 0)\n      syllables.push({\n        text,\n        startOffset: currentOffset,\n        duration\n      })\n      currentOffset += duration\n    })\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(startTime),\n      endTime: Math.round(endTime),\n      syllables\n    })\n  }\n\n  /**\n   * Create a word with weighted syllable distribution (last syllable gets more time) - expects milliseconds\n   */\n  static createWeightedSyllables(wordId: string, wordText: string, startTime: number, endTime: number, syllableTexts: string[], lastSyllableWeight: number = 1.2): RelativeSyllableTiming {\n    const wordDuration = Math.round(endTime - startTime)\n\n    // Calculate weights\n    const weights = syllableTexts.map((_, index) =>\n      index === syllableTexts.length - 1 ? lastSyllableWeight : 1.0\n    )\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n\n    // Create syllables with weighted durations (ensure integer milliseconds)\n    const syllables: RelativeSyllable[] = []\n    let currentOffset = 0\n    let totalAssigned = 0\n\n    syllableTexts.forEach((text, index) => {\n      let duration: number\n      if (index === syllableTexts.length - 1) {\n        // Last syllable gets whatever is left to ensure exact total\n        duration = wordDuration - totalAssigned\n      } else {\n        duration = Math.round((weights[index] / totalWeight) * wordDuration)\n        totalAssigned += duration\n      }\n\n      syllables.push({\n        text,\n        startOffset: currentOffset,\n        duration\n      })\n      currentOffset += duration\n    })\n\n    return new RelativeSyllableTiming({\n      id: wordId,\n      text: wordText,\n      startTime: Math.round(startTime),\n      endTime: Math.round(endTime),\n      syllables\n    })\n  }\n}\n","<!--\nWORD TIMING EDITOR COMPONENT - Design & Behavior Notes\n\nVISION:\n- Single unified timeline component (like a train track with word cars)\n- Horizontal 1px black line with word rectangles sitting on top (kabob-case style)\n- Positioned above waveform viewer for synchronized time viewing\n- Musical timing intelligence: captures word starts via spacebar, assumes note patterns\n\nDURATION-BASED WORKFLOW:\n- Think in terms of DURATIONS rather than end times (more musical/natural)\n- Move operations: preserve duration, change start time\n- Resize operations: preserve start time, change duration\n- Syllable proportions: stored as percentages of word duration\n- Visual width directly represents time duration\n\nBEHAVIORS:\n- Each word box width represents duration visually (start + duration = end)\n- Hot spots: move entire word (preserves duration), resize duration, syllable dividers\n- Smart syllable distribution: first syllables shorter, last longer (NOT equal triplets)\n- Time-locked with waveform: same scale, synchronized scrolling/zooming\n\nINTERACTION PATTERNS:\n- Spacebar tap captures word start times during playback\n- Dragging resize handle changes word duration intelligently\n- Moving words preserves their musical duration\n- Future: keyboard shortcuts for common duration adjustments (quarter note, eighth note, etc.)\n- Cursor feedback shows interaction type (grab/resize/divide)\n\nMUSICAL ASSUMPTIONS:\n- Words have natural durations that should be preserved when moving\n- Duration changes redistribute syllables proportionally (musical phrasing)\n- Start time capture + duration-based editing = natural musical workflow\n- Syllable timing follows musical phrasing (not mechanical equal spacing)\n-->\n\n<template>\n  <div class=\"word-timing-editor\">\n    <!-- Main timeline track with horizontal reference line -->\n    <div class=\"timeline-track\" :class=\"{\n      'with-background': showBackground,\n      'with-border': showBorder\n    }\" ref=\"timelineTrack\">\n      <!-- 1px black horizontal line (the \"track\" for word \"train cars\") -->\n      <div class=\"timeline-baseline\"></div>\n\n      <!-- Word boxes positioned as train cars on the track -->\n      <div v-for=\"word in visibleWords\" :key=\"word.id\" class=\"word-car\" :class=\"{\n        selected: selectedWordId === word.id,\n        dragging: isDragging && draggedWordId === word.id,\n        untimed: word.startTime === 0 && word.endTime === 0\n      }\" :style=\"getWordCarStyle(word)\" @mousedown=\"handleWordMouseDown(word, $event)\">\n        <!-- Word text -->\n        <div class=\"word-text\">{{ word.text }}</div>\n\n        <!-- Hot spots for interaction -->\n        <div class=\"hotspot hotspot-move\" title=\"Drag to move word\" @mousedown.stop=\"startDrag('move', word, $event)\">\n        </div>\n        <div class=\"hotspot hotspot-resize-end\" title=\"Drag to adjust end time\"\n          @mousedown.stop=\"startDrag('resize', word, $event)\"></div>\n\n        <!-- Syllable dividers for multi-syllable words -->\n        <template v-if=\"word.syllables && word.syllables.length > 1\">\n          <div v-for=\"(syllable, index) in word.syllables.slice(0, -1)\" :key=\"`syllable-${index}`\"\n            class=\"hotspot hotspot-syllable-divider\" :style=\"getSyllableDividerStyle(word, index)\"\n            :title=\"`Adjust syllable ${index + 1}/${index + 2} boundary`\"\n            @mousedown.stop=\"startDrag('syllable', word, $event, index)\"></div>\n        </template>\n      </div>\n    </div>\n\n    <!-- Debug panel -->\n    <div v-if=\"showDebug\" class=\"debug-panel\">\n      <h4>Word Timing Editor Debug</h4>\n      <p>Timeline Duration: {{ duration.toFixed(2) }}s</p>\n      <p>\n        View Window: {{ props.viewStart.toFixed(2) }}s - {{ effectiveViewEnd.toFixed(2) }}s ({{ viewDuration.toFixed(2)\n        }}s span)\n      </p>\n      <p>Pixels/Second: {{ pixelsPerSecond.toFixed(1) }}</p>\n      <p>Track Width: {{ trackWidth }}px</p>\n      <p>Total Words: {{ props.words.length }} | Visible: {{ visibleWords.length }}</p>\n      <p>Selected Word: {{ selectedWordId || 'None' }}</p>\n      <p>Drag State: {{ isDragging ? `${dragType} on ${draggedWordId}` : 'None' }}</p>\n      <p v-if=\"isDragging\">Drag Start Time: {{ dragStartTime.toFixed(3) }}s</p>\n      <div v-if=\"selectedWordId\" class=\"selected-word-debug\">\n        <strong>Selected Word Details:</strong>\n        <div class=\"word-timing-summary\">\n          <p v-if=\"visibleWords.find(w => w.id === selectedWordId)\" class=\"timing-info\">\n            Word: \"{{visibleWords.find(w => w.id === selectedWordId)?.text}}\" | Start:\n            {{visibleWords.find(w => w.id === selectedWordId)?.startTime.toFixed(3)}}s | Duration:\n            {{getWordDuration(visibleWords.find(w => w.id === selectedWordId)!).toFixed(3)}}s\n          </p>\n          <div v-if=\"visibleWords.find(w => w.id === selectedWordId)?.syllables\" class=\"syllable-durations\">\n            <strong>Syllable Durations:</strong>\n            <div v-for=\"(syllable, index) in visibleWords.find(w => w.id === selectedWordId)?.syllables\" :key=\"index\"\n              class=\"syllable-info\">\n              \"{{ syllable.text }}\": {{ getSyllableDuration(syllable).toFixed(3) }}s ({{\n                (\n                  (getSyllableDuration(syllable) / getWordDuration(visibleWords.find(w => w.id === selectedWordId)!)) *\n                  100\n                ).toFixed(1)\n              }}%)\n            </div>\n          </div>\n        </div>\n        <details>\n          <summary>Raw JSON Data</summary>\n          <pre>{{\n            JSON.stringify(\n              visibleWords.find(w => w.id === selectedWordId),\n              null,\n              2\n            )\n          }}</pre>\n        </details>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'\nimport { TIMING } from '@/models/TimingConstants'\n\ninterface Syllable {\n  text: string\n  startTime: number\n  endTime: number\n  // Note: We'll calculate duration as endTime - startTime when needed\n}\n\ninterface Word {\n  id: string\n  text: string\n  startTime: number\n  endTime: number // Keep for compatibility, but think in terms of startTime + duration\n  syllables?: Syllable[]\n  // Internal: We'll work with duration = endTime - startTime\n}\n\ninterface Props {\n  words: Word[]\n  duration: number\n  viewStart?: number\n  viewEnd?: number\n  showDebug?: boolean\n  showBackground?: boolean\n  showBorder?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  viewStart: 0,\n  viewEnd: undefined,\n  showDebug: false,\n  showBackground: false,\n  showBorder: false,\n})\n\n// console.log('🔧 WordTimingEditor props received:', {\n//   words: props.words.length,\n//   duration: props.duration,\n//   viewStart: props.viewStart,\n//   viewEnd: props.viewEnd,\n//   showDebug: props.showDebug\n// })\n\nconst emit = defineEmits<{\n  'update:words': [words: Word[]]\n  'select-word': [wordId: string | null]\n}>()\n\n// Refs\nconst timelineTrack = ref<HTMLElement>()\nconst selectedWordId = ref<string | null>(null)\n\n// Drag state\nconst isDragging = ref(false)\nconst draggedWordId = ref<string | null>(null)\nconst dragType = ref<'move' | 'resize' | 'syllable'>('move')\nconst dragStartX = ref(0)\nconst dragStartTime = ref(0)\nconst dragSyllableIndex = ref(0)\n\n// Timeline calculations\nconst trackWidth = ref(800) // Will be updated on mount\nconst effectiveViewEnd = computed(() => props.viewEnd || props.duration)\nconst viewDuration = computed(() => effectiveViewEnd.value - props.viewStart)\nconst pixelsPerSecond = computed(() => trackWidth.value / viewDuration.value)\n\n// Visible words - Strict to show only word fully within viewport\nconst visibleWords = computed(() => {\n  const buffer = 0.02 // No buffer - words appear/disappear exactly at viewport edges\n\n  // console.log('👁️ Calculating visibleWords:', {\n  //   totalWords: props.words.length,\n  //   viewStart: props.viewStart,\n  //   viewEnd: effectiveViewEnd.value,\n  //   duration: props.duration,\n  //   firstFewWords: props.words.slice(0, 3).map(w => ({\n  //     text: w.text,\n  //     startTime: w.startTime,\n  //     endTime: w.endTime,\n  //     isUntimed: w.startTime === 0 && w.endTime === 0\n  //   }))\n  // })\n\n  const filtered = props.words.filter(word => {\n    // Skip words with no timing (startTime and endTime both 0) - they clutter the interface\n    const isUntimed = word.startTime === 0 && word.endTime === 0\n    if (isUntimed) {\n      // console.log('👁️ Skipping untimed word:', word.text)\n      return false // Hide untimed words\n    }\n\n    // For words with timing, check if they're COMPLETELY within the visible time range\n    // Only show words where BOTH start and end are within the viewport\n    // This prevents visual issues where partial words \"stick\" at viewport edges\n    const wordStart = word.startTime\n    const wordEnd = word.endTime\n    const viewWindowStart = props.viewStart - buffer\n    const viewWindowEnd = effectiveViewEnd.value + buffer\n\n    // A word is visible only if it's completely contained in the viewport\n    const inRange = wordStart >= viewWindowStart && wordEnd <= viewWindowEnd\n\n    // console.log('👁️ Word range check:', {\n    //   text: word.text,\n    //   wordStart,\n    //   wordEnd,\n    //   viewWindowStart,\n    //   viewWindowEnd,\n    //   inRange,\n    //   viewStart: props.viewStart,\n    //   viewEnd: effectiveViewEnd.value\n    // })\n\n    return inRange\n  })\n\n  // console.log('👁️ Visible words result:', {\n  //   visible: filtered.length,\n  //   words: filtered.map(w => w.text)\n  // })\n\n  return filtered\n})\n\n// Convert time to pixels with proper bounds checking\nconst timeToPixels = (time: number): number => {\n  const relativeTime = time - props.viewStart\n  return relativeTime * pixelsPerSecond.value\n}\n\n// Convert pixels to time with proper bounds checking\n// const pixelsToTime = (pixels: number): number => {\n//   return props.viewStart + pixels / pixelsPerSecond.value\n// }\n\n// Get CSS style for word car positioning with bounds checking\nconst getWordCarStyle = (word: Word) => {\n  // Special handling for untimed words (both startTime and endTime are 0)\n  if (word.startTime === 0 && word.endTime === 0) {\n    // Position untimed words sequentially at the beginning\n    const untimedWords = props.words.filter(w => w.startTime === 0 && w.endTime === 0)\n    const wordIndex = untimedWords.findIndex(w => w.id === word.id)\n    const wordWidth = Math.max(word.text.length * 8 + 20, 60) // Width based on text length, minimum 60px\n    const leftPosition = wordIndex * (wordWidth + 5) // 5px gap between untimed words\n\n    return {\n      left: `${leftPosition}px`,\n      width: `${wordWidth}px`,\n    }\n  }\n\n  // Normal handling for timed words\n  const startPixels = timeToPixels(word.startTime)\n  const endPixels = timeToPixels(word.endTime)\n  const width = endPixels - startPixels\n\n  // Ensure minimum width and proper positioning\n  const safeLeft = Math.max(0, startPixels)\n  const safeWidth = Math.max(width, 24) // Minimum 24px for usable hotspots\n\n  // Clamp to track bounds but allow slight overflow for edge cases\n  const maxLeft = trackWidth.value - 24\n  const finalLeft = Math.min(safeLeft, maxLeft)\n  const finalWidth = Math.min(safeWidth, trackWidth.value - finalLeft)\n\n  return {\n    left: `${finalLeft}px`,\n    width: `${finalWidth}px`,\n  }\n}\n\n// Get CSS style for syllable divider positioning with bounds checking\nconst getSyllableDividerStyle = (word: Word, syllableIndex: number) => {\n  if (!word.syllables || syllableIndex >= word.syllables.length - 1) return { display: 'none' }\n\n  const wordStartPixels = timeToPixels(word.startTime)\n  const syllableEndPixels = timeToPixels(word.syllables[syllableIndex].endTime)\n  const wordWidth = timeToPixels(word.endTime) - wordStartPixels\n\n  // Calculate position relative to word start, with bounds checking\n  const relativePosition = syllableEndPixels - wordStartPixels\n  const safePosition = Math.max(6, Math.min(relativePosition, wordWidth - 6)) // Keep within word bounds\n\n  return {\n    left: `${safePosition}px`,\n    display: wordWidth > 20 ? 'block' : 'none', // Hide dividers in very narrow words\n  }\n}\n\n// Mouse event handlers\nconst handleWordMouseDown = (word: Word, event: MouseEvent) => {\n  event.preventDefault()\n  selectedWordId.value = word.id\n  emit('select-word', word.id)\n}\n\n// Store original syllable proportions for move operations\nconst originalSyllableProportions = ref<{ [wordId: string]: number[] }>({})\n\n// Duration-based helper functions for more natural workflow\nconst getWordDuration = (word: Word): number => Math.max(TIMING.word.minDuration / 1000, word.endTime - word.startTime)\nconst getSyllableDuration = (syllable: Syllable): number => syllable.endTime - syllable.startTime\n\n// Validate and fix word timing to prevent negative durations\nconst validateWordTiming = (word: Word): Word => {\n  if (word.endTime <= word.startTime) {\n    const minEndTime = word.startTime + TIMING.word.minDuration / 1000\n    return {\n      ...word,\n      endTime: minEndTime\n    }\n  }\n  return word\n}\n\nconst setWordDuration = (word: Word, newDuration: number): Word => ({\n  ...word,\n  endTime: word.startTime + newDuration,\n})\n\nconst moveWord = (word: Word, newStartTime: number): Word => {\n  const duration = getWordDuration(word)\n  return {\n    ...word,\n    startTime: newStartTime,\n    endTime: newStartTime + duration,\n  }\n}\n\nconst startDrag = (type: 'move' | 'resize' | 'syllable', word: Word, event: MouseEvent, syllableIndex?: number) => {\n  event.preventDefault()\n  event.stopPropagation()\n\n  isDragging.value = true\n  draggedWordId.value = word.id\n  dragType.value = type\n  dragStartX.value = event.clientX\n  // Set drag start time based on operation type\n  if (type === 'move') {\n    dragStartTime.value = word.startTime\n  } else if (type === 'resize') {\n    dragStartTime.value = word.endTime\n  } else if (type === 'syllable' && typeof syllableIndex === 'number' && word.syllables) {\n    dragStartTime.value = word.syllables[syllableIndex].endTime\n    dragSyllableIndex.value = syllableIndex\n    console.log(`🎯 Starting syllable drag: word=\"${word.text}\", syllable=${syllableIndex}, boundary=${dragStartTime.value.toFixed(3)}s`)\n  }\n\n  // Store original syllable proportions for this word (duration-based)\n  if (word.syllables && word.syllables.length > 1) {\n    const wordDuration = getWordDuration(word)\n    originalSyllableProportions.value[word.id] = word.syllables.map(syllable => getSyllableDuration(syllable) / wordDuration)\n  }\n\n  selectedWordId.value = word.id\n  emit('select-word', word.id)\n\n  // Add global mouse event listeners\n  document.addEventListener('mousemove', handleMouseMove)\n  document.addEventListener('mouseup', handleMouseUp)\n\n  // Add visual feedback\n  document.body.style.cursor = type === 'move' ? 'grabbing' : 'col-resize'\n  document.body.style.userSelect = 'none'\n}\n\nconst handleMouseMove = (event: MouseEvent) => {\n  if (!isDragging.value || !draggedWordId.value) return\n\n  const deltaX = event.clientX - dragStartX.value\n  const deltaTime = deltaX / pixelsPerSecond.value\n\n  const wordIndex = props.words.findIndex(w => w.id === draggedWordId.value)\n  if (wordIndex === -1) return\n\n  const updatedWords = [...props.words]\n  const word = { ...updatedWords[wordIndex] }\n\n  // Get neighboring words for collision detection\n  const previousWord = wordIndex > 0 ? props.words[wordIndex - 1] : null\n  const nextWord = wordIndex < props.words.length - 1 ? props.words[wordIndex + 1] : null\n\n  if (dragType.value === 'move') {\n    // Move entire word - duration stays the same, only start time changes\n    const wordDuration = getWordDuration(word)\n    let newStartTime = Math.max(0, dragStartTime.value + deltaTime)\n\n    // Debug: log original and calculated values\n    console.log(`🔧 Moving \"${word.text}\": original=${word.startTime}-${word.endTime} (${wordDuration}s), newStart=${newStartTime}`)\n\n    // Smart collision detection - allow swapping when words are overlapped\n    const isMovingLeft = newStartTime < word.startTime\n    const isMovingRight = newStartTime > word.startTime\n\n    // Check if we're trying to move past an overlapped word\n    const isPreviousOverlapped = previousWord && previousWord.endTime > word.startTime\n    const isNextOverlapped = nextWord && nextWord.startTime < word.endTime\n\n    console.log(`🔧 Collision check: movingLeft=${isMovingLeft}, movingRight=${isMovingRight}, prevOverlapped=${isPreviousOverlapped}, nextOverlapped=${isNextOverlapped}`)\n\n    // Apply constraints, but allow swapping past overlapped words\n    if (previousWord && !isPreviousOverlapped) {\n      // Normal case: prevent overlap with non-overlapped previous word\n      newStartTime = Math.max(newStartTime, previousWord.endTime + TIMING.word.collisionMargin / 1000)\n    } else if (previousWord && isPreviousOverlapped && isMovingLeft) {\n      // Allow moving left past overlapped previous word, but not too far\n      const minStartTime = Math.max(0, previousWord.startTime - wordDuration - TIMING.word.collisionMargin / 1000)\n      newStartTime = Math.max(newStartTime, minStartTime)\n    }\n\n    if (nextWord && !isNextOverlapped) {\n      // Normal case: prevent overlap with non-overlapped next word\n      const maxStartTime = nextWord.startTime - wordDuration - TIMING.word.collisionMargin / 1000\n      newStartTime = Math.min(newStartTime, maxStartTime)\n    } else if (nextWord && isNextOverlapped && isMovingRight) {\n      // Allow moving right past overlapped next word, but not too far\n      const maxStartTime = nextWord.endTime + TIMING.word.collisionMargin / 1000\n      newStartTime = Math.min(newStartTime, maxStartTime)\n    }\n\n    // Also constrain to view window to prevent disappearing\n    const viewportBuffer = TIMING.editor.viewportBuffer / 1000\n    const maxViewStartTime = effectiveViewEnd.value - wordDuration - viewportBuffer\n    newStartTime = Math.min(newStartTime, maxViewStartTime)\n    newStartTime = Math.max(newStartTime, props.viewStart - viewportBuffer)\n\n    // Apply the move (preserving duration)\n    const movedWord = moveWord(word, newStartTime)\n    console.log(`🔧 After moveWord: ${movedWord.startTime}-${movedWord.endTime}`)\n\n    word.startTime = movedWord.startTime\n    word.endTime = movedWord.endTime\n\n    // Update syllable timings using stored proportions (preserving their durations)\n    if (word.syllables && originalSyllableProportions.value[word.id]) {\n      const proportions = originalSyllableProportions.value[word.id]\n      let syllableStartTime = newStartTime\n\n      word.syllables = word.syllables.map((syllable, index) => {\n        const syllableDuration = proportions[index] * wordDuration\n        const result = {\n          ...syllable,\n          startTime: syllableStartTime,\n          endTime: syllableStartTime + syllableDuration,\n        }\n        syllableStartTime += syllableDuration\n        return result\n      })\n    }\n  } else if (dragType.value === 'resize') {\n    // Resize duration - drag the end time directly\n    let newEndTime = Math.max(word.startTime + TIMING.word.minDuration / 1000, dragStartTime.value + deltaTime)\n    let newDuration = newEndTime - word.startTime\n\n    // Constrain resize to not overlap with next word\n    if (nextWord) {\n      const maxDuration = nextWord.startTime - word.startTime - TIMING.word.collisionMargin / 1000\n      newDuration = Math.min(newDuration, maxDuration)\n      newEndTime = word.startTime + newDuration\n    }\n\n    // Constrain to reasonable view bounds\n    const maxEndTime = effectiveViewEnd.value + TIMING.editor.viewportBuffer / 1000\n    if (newEndTime > maxEndTime) {\n      newDuration = maxEndTime - word.startTime\n      newEndTime = maxEndTime\n    }\n\n    // Apply the new duration\n    const resizedWord = setWordDuration(word, newDuration)\n    word.endTime = resizedWord.endTime\n\n    // DON'T redistribute syllables - keep them at absolute positions (like test rig)\n    // User has carefully placed s-breaks and they should not move during word resize\n    // if (word.syllables && word.syllables.length > 1) {\n    //   word.syllables = distributeSyllableTiming(word, newDuration, word.syllables.length)\n    // }\n  } else if (dragType.value === 'syllable') {\n    // Adjust syllable boundary\n    if (word.syllables && dragSyllableIndex.value < word.syllables.length - 1) {\n      const syllableMargin = TIMING.syllable.minDuration / 1000 / 2 // Half of min duration in seconds for boundary adjustment\n      const newBoundaryTime = Math.max(\n        word.syllables[dragSyllableIndex.value].startTime + syllableMargin,\n        Math.min(word.syllables[dragSyllableIndex.value + 1].endTime - syllableMargin, dragStartTime.value + deltaTime)\n      )\n\n      // Debug logging for syllable boundary adjustment\n      console.log(`🔧 Syllable boundary: \"${word.syllables[dragSyllableIndex.value].text}\" | \"${word.syllables[dragSyllableIndex.value + 1].text}\" → ${newBoundaryTime.toFixed(3)}s`)\n\n      word.syllables[dragSyllableIndex.value].endTime = newBoundaryTime\n      word.syllables[dragSyllableIndex.value + 1].startTime = newBoundaryTime\n    }\n  }\n\n  // Validate and fix word timing before updating\n  const validatedWord = validateWordTiming(word)\n\n  updatedWords[wordIndex] = validatedWord\n\n  // Emit immediately so parent gets syllable changes for s-break drags\n  // Performance is now acceptable with direct syllable updates (no RelativeSyllableTiming recalc)\n  const validatedWords = updatedWords.map(validateWordTiming)\n  emit('update:words', validatedWords)\n}\n\nconst handleMouseUp = () => {\n  // Clear stored proportions for completed drag\n  if (draggedWordId.value && originalSyllableProportions.value[draggedWordId.value]) {\n    delete originalSyllableProportions.value[draggedWordId.value]\n  }\n\n  isDragging.value = false\n  draggedWordId.value = null\n\n  // Remove global listeners\n  document.removeEventListener('mousemove', handleMouseMove)\n  document.removeEventListener('mouseup', handleMouseUp)\n\n  // Reset cursor\n  document.body.style.cursor = ''\n  document.body.style.userSelect = ''\n}\n\n// Smart syllable timing distribution (musical pattern: shorter first, longer last)\n// const distributeSyllableTiming = (word: Word, totalDuration: number, syllableCount: number): Syllable[] => {\n//   if (!word.syllables || syllableCount <= 1) return word.syllables || []\n\n//   // Use centralized syllable weighting system\n//   const weights = TimingUtils.calculateSyllableWeights(syllableCount)\n\n//   const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n//   const syllableDurations = weights.map(weight => (weight / totalWeight) * totalDuration)\n\n//   let currentTime = word.startTime\n//   return word.syllables\n//     .map((syllable, index) => ({\n//       ...syllable,\n//       startTime: currentTime,\n//       endTime: currentTime + syllableDurations[index],\n//     }))\n//     .map((syllable, index, array) => {\n//       currentTime = syllable.endTime\n//       // Ensure last syllable ends exactly at word end\n//       if (index === array.length - 1) {\n//         syllable.endTime = word.endTime\n//       }\n//       return syllable\n//     })\n// }\n\n// Setup timeline width on mount\nonMounted(async () => {\n  await nextTick() // Wait for DOM to be fully rendered\n\n  const updateTrackWidth = () => {\n    if (timelineTrack.value) {\n      const newWidth = timelineTrack.value.clientWidth\n      if (newWidth > 0) {\n        trackWidth.value = newWidth\n        // console.log('📏 Track width updated:', newWidth)\n      }\n    }\n  }\n\n  updateTrackWidth()\n\n  // Also update after another tick in case the parent container is still sizing\n  setTimeout(updateTrackWidth, 100)\n\n  window.addEventListener('resize', updateTrackWidth)\n\n  onUnmounted(() => {\n    window.removeEventListener('resize', updateTrackWidth)\n  })\n})\n\n// Watch for changes that might affect layout\nwatch([() => props.viewStart, () => props.viewEnd, () => props.duration], () => {\n  // console.log('🔄 WordTimingEditor props changed:', {\n  //   viewStart: {\n  //     old: oldValues?.[0], new: newValues[0]\n  //   },\n  //   viewEnd: {\n  //     old: oldValues?.[1], new: newValues[1]\n  //   },\n  //   duration: {\n  //     old: oldValues?.[2], new: newValues[2]\n  //   }\n  // })\n\n  // Update track width when view parameters change\n  nextTick(() => {\n    if (timelineTrack.value) {\n      const newWidth = timelineTrack.value.clientWidth\n      if (newWidth > 0 && newWidth !== trackWidth.value) {\n        trackWidth.value = newWidth\n        // console.log('📏 Track width updated (via watcher):', newWidth)\n      }\n    }\n  })\n}, { flush: 'post' })\n\n// Cleanup on unmount\nonUnmounted(() => {\n  document.removeEventListener('mousemove', handleMouseMove)\n  document.removeEventListener('mouseup', handleMouseUp)\n})\n</script>\n\n<style scoped>\n.word-timing-editor {\n  width: 100%;\n  margin: 5px 0px;\n  padding: 0px 4px\n}\n\n.timeline-track {\n  position: relative;\n  height: 40px;\n  overflow: hidden;\n}\n\n/* Optional background styling */\n.timeline-track.with-background {\n  background: linear-gradient(to bottom, #fafafa 0%, #f0f0f0 100%);\n  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n/* Optional border styling */\n.timeline-track.with-border {\n  border: 1px solid #c4c4c4;\n  border-radius: 6px;\n}\n\n/* The 1px black horizontal line (train track) */\n.timeline-baseline {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  height: 1px;\n  background: #bbbbbb;\n  z-index: 1;\n}\n\n/* Word boxes (train cars) */\n.word-car {\n  position: absolute;\n  top: 50%;\n  height: 28px;\n  transform: translateY(-50%);\n  background: #e3f2fd;\n  border: 1px solid #1976d2;\n  border-radius: 3px;\n  cursor: grab;\n  z-index: 10;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.1s ease;\n}\n\n.word-car:hover {\n  background: #bbdefb;\n  border-color: #1565c0;\n  z-index: 15;\n}\n\n.word-car:hover .word-text {\n  color: #0a3a7a;\n  text-shadow: 0 1px 2px rgba(255, 255, 255, 1);\n}\n\n.word-car.untimed {\n  background: #fff8e1;\n  border: 2px dashed #ff8f00;\n  border-color: #ff8f00;\n  opacity: 0.8;\n}\n\n.word-car.untimed:hover {\n  background: #fff3e0;\n  opacity: 1;\n  border-style: solid;\n}\n\n.word-car.selected {\n  background: #fff3e0;\n  border-color: #f57c00;\n  box-shadow: 0 0 0 2px rgba(245, 124, 0, 0.4);\n  z-index: 20;\n}\n\n.word-car.selected .word-text {\n  color: #bf360c;\n  font-weight: 600;\n  text-shadow: none;\n}\n\n.word-car.dragging {\n  cursor: grabbing;\n  z-index: 25;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  background: #fff8e1;\n  border-color: #ff8f00;\n}\n\n.word-car.dragging .word-text {\n  color: #ef6c00;\n  text-shadow: 0 1px 3px rgba(255, 255, 255, 1);\n}\n\n.word-text {\n  color: #0d47a1;\n  font-size: 11px;\n  font-weight: 700;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  pointer-events: none;\n  padding: 0 6px;\n  text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);\n}\n\n/* Hot spots for interaction */\n.hotspot {\n  position: absolute;\n  background: rgba(255, 255, 255, 0.7);\n  border-radius: 2px;\n  z-index: 30;\n}\n\n.hotspot-move {\n  top: 2px;\n  left: 2px;\n  right: 2px;\n  bottom: 2px;\n  cursor: grab;\n}\n\n.hotspot-move:hover {\n  background: rgba(255, 255, 255, 0.9);\n}\n\n.hotspot-resize-end {\n  top: -2px;\n  right: -4px;\n  width: 8px;\n  height: calc(100% + 4px);\n  cursor: col-resize;\n  background: rgba(76, 175, 80, 0.8);\n  border-radius: 0 3px 3px 0;\n  border: 1px solid rgba(76, 175, 80, 1);\n}\n\n.hotspot-resize-end:hover {\n  background: rgba(76, 175, 80, 1);\n  width: 10px;\n  right: -5px;\n  box-shadow: 0 0 4px rgba(76, 175, 80, 0.6);\n}\n\n.hotspot-syllable-divider {\n  top: -2px;\n  width: 6px;\n  height: calc(100% + 4px);\n  cursor: col-resize;\n  background: rgba(255, 152, 0, 0.8);\n  transform: translateX(-3px);\n  border-radius: 2px;\n  border: 1px solid rgba(255, 152, 0, 1);\n}\n\n.hotspot-syllable-divider:hover {\n  background: rgba(255, 152, 0, 1);\n  width: 8px;\n  transform: translateX(-4px);\n  box-shadow: 0 0 4px rgba(255, 152, 0, 0.6);\n}\n\n/* Debug panel */\n.debug-panel {\n  margin-top: 10px;\n  padding: 12px;\n  background: #f8f9fa;\n  border: 1px solid #dee2e6;\n  border-radius: 4px;\n  font-size: 12px;\n  font-family: 'Courier New', monospace;\n}\n\n.debug-panel h4 {\n  margin: 0 0 8px 0;\n  font-size: 14px;\n  font-family: inherit;\n}\n\n.debug-panel p {\n  margin: 2px 0;\n  line-height: 1.4;\n}\n\n.selected-word-debug {\n  margin-top: 8px;\n  padding: 8px;\n  background: #e9ecef;\n  border-radius: 3px;\n  max-height: 200px;\n  overflow-y: auto;\n}\n\n.selected-word-debug pre {\n  margin: 4px 0 0 0;\n  font-size: 10px;\n  line-height: 1.2;\n}\n\n.word-timing-summary {\n  font-family: 'Courier New', monospace;\n  font-size: 11px;\n}\n\n.timing-info {\n  background: #d1ecf1;\n  padding: 4px 6px;\n  border-radius: 3px;\n  margin: 4px 0;\n  border-left: 3px solid #0c5460;\n}\n\n.syllable-durations {\n  margin-top: 6px;\n}\n\n.syllable-info {\n  padding: 2px 4px;\n  margin: 1px 0;\n  background: #fff3cd;\n  border-radius: 2px;\n  font-size: 10px;\n}\n\ndetails {\n  margin-top: 8px;\n}\n\nsummary {\n  cursor: pointer;\n  font-size: 10px;\n  color: #6c757d;\n}\n</style>\n"],"names":["RelativeSyllableTiming","word","constructor","wordData","this","validateSyllables","syllables","length","Error","currentOffset","syllable","offsetError","Math","abs","startOffset","TIMING","validation","timingPrecision","text","duration","expectedWordDuration","endTime","startTime","actualSyllablesTotalDuration","durationTolerance","getWordData","getWordDuration","getAbsoluteSyllables","map","moveWord","newStartTime","resizeWordEnd","newEndTime","newWordDuration","lastIndex","newLastSyllableDuration","resizeWordStart","oldFirstDuration","newFirstDuration","deltaOffset","i","moveAndResize","adjustSyllableBoundary","syllableIndex","absoluteNewEndTime","currentSyllable","nextSyllable","newCurrentDuration","nextSyllableEndOffset","fromAbsoluteSyllables","wordId","wordText","wordStartTime","wordEndTime","absoluteSyllables","cleanedSyllables","currentTime","isLast","round","gapTolerance","max","minDuration","push","relativeSyllables","expectedOffset","safeDuration","actualWordDuration","reduce","sum","syl","adjustedWordEndTime","originalWordDuration","id","fromSecondsData","wordStartSeconds","wordEndSeconds","syllableTexts","lastSyllableWeight","createWeightedSyllables","toSecondsData","createEvenSyllables","wordDuration","baseSyllableDuration","floor","remainder","forEach","index","weights","_","totalWeight","weight","totalAssigned","exports","props","__props","emit","__emit","timelineTrack","ref","selectedWordId","isDragging","draggedWordId","dragType","dragStartX","dragStartTime","dragSyllableIndex","trackWidth","effectiveViewEnd","computed","viewEnd","viewDuration","value","viewStart","pixelsPerSecond","visibleWords","words","filter","wordStart","wordEnd","viewWindowStart","viewWindowEnd","timeToPixels","time","getWordCarStyle","wordIndex","w","findIndex","wordWidth","left","width","startPixels","safeLeft","safeWidth","maxLeft","finalLeft","min","getSyllableDividerStyle","display","wordStartPixels","syllableEndPixels","relativePosition","originalSyllableProportions","getSyllableDuration","validateWordTiming","minEndTime","startDrag","type","event","preventDefault","stopPropagation","clientX","console","log","toFixed","document","addEventListener","handleMouseMove","handleMouseUp","body","style","cursor","userSelect","deltaTime","updatedWords","previousWord","nextWord","isMovingLeft","isMovingRight","isPreviousOverlapped","isNextOverlapped","collisionMargin","minStartTime","maxStartTime","viewportBuffer","editor","maxViewStartTime","movedWord","proportions","syllableStartTime","syllableDuration","result","newDuration","maxDuration","maxEndTime","resizedWord","setWordDuration","syllableMargin","newBoundaryTime","validatedWord","validatedWords","removeEventListener","onMounted","async","nextTick","updateTrackWidth","newWidth","clientWidth","setTimeout","window","onUnmounted","watch","flush","_openBlock","_createElementBlock","_hoisted_1","_createElementVNode","class","showBackground","showBorder","_Fragment","_renderList","key","dragging","untimed","_normalizeStyle","onMousedown","$event","handleWordMouseDown","_hoisted_3","_toDisplayString","title","_withModifiers","slice","showDebug","_hoisted_7","_cache","_hoisted_9","_hoisted_10","find","_hoisted_11","_hoisted_12","JSON","stringify"],"mappings":"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"}