{"version":3,"file":"lyricsParser-c2c86582.js","sources":["../../src/models/KaraokeTimingEngine.ts","../../src/models/TimingConstants.ts","../../src/utils/lyricsParser.ts"],"sourcesContent":["/**\n * Pure TypeScript Karaoke Timing Engine\n * Handles all timing logic independent of Vue/UI\n * Can be tested with synthetic time progression\n */\n\nimport type { LyricLine, WordTiming } from '@/types/karaoke'\n\nexport interface TimingEvent {\n  type: 'word_start' | 'word_end' | 'syllable_start' | 'syllable_end' | 'line_start' | 'line_end' | 'phrase_gap'\n  timestamp: number\n  lineIndex: number\n  wordIndex?: number\n  syllableIndex?: number\n  text?: string\n  expectedDuration?: number\n}\n\nexport interface TimingConfiguration {\n  // Syllable timing weights\n  syllableWeights: {\n    first: number\n    middle: number\n    last: number\n  }\n\n  // Gap detection settings\n  gaps: {\n    shortPause: number // ms - comma, short breath\n    mediumPause: number // ms - period, end of phrase\n    longPause: number // ms - line break, new verse\n  }\n\n  // Minimum durations\n  minimums: {\n    syllableDuration: number // ms\n    wordDuration: number // ms\n    lineDuration: number // ms\n  }\n}\n\nexport class KaraokeTimingEngine {\n  private lyrics: LyricLine[] = []\n  private eventLog: TimingEvent[] = []\n  private config: TimingConfiguration\n  private silent: boolean\n\n  constructor(config?: Partial<TimingConfiguration> & { silent?: boolean }) {\n    this.silent = config?.silent || false\n\n    this.config = {\n      syllableWeights: {\n        first: 0.7,\n        middle: 0.8,\n        last: 2.0\n      },\n      gaps: {\n        shortPause: 100,   // comma, quick breath\n        mediumPause: 300,  // period, phrase end\n        longPause: 800     // line break, verse change\n      },\n      minimums: {\n        syllableDuration: 150,\n        wordDuration: 200,\n        lineDuration: 1000\n      },\n      ...config\n    }\n\n    this.log('ENGINE_INIT', 0, -1, undefined, undefined, 'Karaoke Timing Engine initialized')\n  }\n\n  /**\n   * Load lyrics into the engine\n   */\n  loadLyrics(lyrics: LyricLine[]): void {\n    this.lyrics = [...lyrics]\n    this.eventLog = []\n    this.log('LYRICS_LOADED', 0, -1, undefined, undefined, `Loaded ${lyrics.length} lines`)\n  }\n\n  /**\n   * Apply timing to a word at the current timestamp\n   */\n  assignWordTiming(lineIndex: number, wordIndex: number, timestamp: number): TimingEvent[] {\n    const events: TimingEvent[] = []\n\n    if (!this.isValidPosition(lineIndex, wordIndex)) {\n      this.log('ERROR_INVALID_POSITION', timestamp, lineIndex, wordIndex)\n      return events\n    }\n\n    const word = this.lyrics[lineIndex].words[wordIndex]\n    const previousWord = this.getPreviousWord(lineIndex, wordIndex)\n\n    // Finalize previous word if it exists and has timing\n    if (previousWord && previousWord.word.startTime !== undefined) {\n      const actualDuration = timestamp - previousWord.word.startTime\n      this.finalizeWordTiming(previousWord, actualDuration, timestamp)\n\n      events.push({\n        type: 'word_end',\n        timestamp,\n        lineIndex: previousWord.lineIndex,\n        wordIndex: previousWord.wordIndex,\n        text: previousWord.word.word,\n        expectedDuration: actualDuration\n      })\n\n      // Detect gap between words\n      const gap = this.detectGap(word.word, actualDuration)\n      if (gap > this.config.gaps.shortPause) {\n        events.push({\n          type: 'phrase_gap',\n          timestamp,\n          lineIndex,\n          wordIndex,\n          expectedDuration: gap\n        })\n      }\n    }\n\n    // Start new word\n    word.startTime = timestamp\n    word.endTime = undefined // Will be set when next word starts\n\n    events.push({\n      type: 'word_start',\n      timestamp,\n      lineIndex,\n      wordIndex,\n      text: word.word\n    })\n\n    this.log('WORD_ASSIGNED', timestamp, lineIndex, wordIndex, undefined, word.word)\n    return events\n  }\n\n  /**\n   * Finalize all remaining words (end of song)\n   */\n  finalizeAllTiming(endTimestamp: number): TimingEvent[] {\n    const events: TimingEvent[] = []\n\n    // Find the last word with timing\n    const lastWord = this.findLastTimedWord()\n    if (lastWord && lastWord.word.startTime !== undefined) {\n      const estimatedDuration = this.estimateWordDuration(lastWord.word)\n      this.finalizeWordTiming(lastWord, estimatedDuration, endTimestamp)\n\n      events.push({\n        type: 'word_end',\n        timestamp: endTimestamp,\n        lineIndex: lastWord.lineIndex,\n        wordIndex: lastWord.wordIndex,\n        text: lastWord.word.word,\n        expectedDuration: estimatedDuration\n      })\n    }\n\n    this.log('TIMING_FINALIZED', endTimestamp, -1)\n    return events\n  }\n\n  /**\n   * Get current position based on timestamp\n   */\n  getCurrentPosition(timestamp: number): {\n    lineIndex: number\n    wordIndex: number\n    syllableIndex: number\n    isActive: boolean\n  } {\n    for (let lineIndex = 0; lineIndex < this.lyrics.length; lineIndex++) {\n      const line = this.lyrics[lineIndex]\n\n      for (let wordIndex = 0; wordIndex < line.words.length; wordIndex++) {\n        const word = line.words[wordIndex]\n\n        if (word.startTime !== undefined) {\n          if (word.endTime !== undefined) {\n            // Finalized word - use exact timing\n            // Use < for endTime to ensure proper word transitions at boundaries\n            if (timestamp >= word.startTime && timestamp < word.endTime) {\n              const syllableIndex = this.findCurrentSyllable(word, timestamp)\n              return {\n                lineIndex, wordIndex, syllableIndex, isActive: true\n              }\n            }\n          } else {\n            // Current active word (not finalized yet)\n            // Check if this is the current word by seeing if timestamp is after its start\n            // and there's no next word with timing yet\n            if (timestamp >= word.startTime) {\n              // Check if there's a next word that started\n              const nextWord = this.getNextWord(lineIndex, wordIndex)\n              if (!nextWord || nextWord.word.startTime === undefined || timestamp < nextWord.word.startTime) {\n                // This is the current active word\n                const syllableIndex = this.findCurrentSyllable(word, timestamp)\n                return {\n                  lineIndex, wordIndex, syllableIndex, isActive: true\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      lineIndex: 0, wordIndex: 0, syllableIndex: 0, isActive: false\n    }\n  }\n\n  /**\n   * Get all events that occurred during timing\n   */\n  getEventLog(): TimingEvent[] {\n    return [...this.eventLog]\n  }\n\n  /**\n   * Get timing statistics\n   */\n  getStats(): {\n    totalWords: number\n    timedWords: number\n    totalSyllables: number\n    timedSyllables: number\n    averageWordDuration: number\n    completionPercent: number\n    eventCount: number\n  } {\n    let totalWords = 0\n    let timedWords = 0\n    let totalSyllables = 0\n    let timedSyllables = 0\n    let totalDuration = 0\n\n    this.lyrics.forEach(line => {\n      line.words.forEach(word => {\n        totalWords++\n        if (word.startTime !== undefined) {\n          timedWords++\n          if (word.endTime !== undefined) {\n            totalDuration += (word.endTime - word.startTime)\n          }\n        }\n\n        word.syllables.forEach(syllable => {\n          totalSyllables++\n          if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n            timedSyllables++\n          }\n        })\n      })\n    })\n\n    return {\n      totalWords,\n      timedWords,\n      totalSyllables,\n      timedSyllables,\n      averageWordDuration: timedWords > 0 ? totalDuration / timedWords : 0,\n      completionPercent: totalWords > 0 ? (timedWords / totalWords) * 100 : 0,\n      eventCount: this.eventLog.length\n    }\n  }\n\n  // Private helper methods\n\n  private isValidPosition(lineIndex: number, wordIndex: number): boolean {\n    return lineIndex >= 0 &&\n      lineIndex < this.lyrics.length &&\n      wordIndex >= 0 &&\n      wordIndex < this.lyrics[lineIndex].words.length\n  }\n\n  private getPreviousWord(lineIndex: number, wordIndex: number): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    if (wordIndex > 0) {\n      return {\n        lineIndex,\n        wordIndex: wordIndex - 1,\n        word: this.lyrics[lineIndex].words[wordIndex - 1]\n      }\n    } else if (lineIndex > 0) {\n      const prevLine = this.lyrics[lineIndex - 1]\n      if (prevLine.words.length > 0) {\n        return {\n          lineIndex: lineIndex - 1,\n          wordIndex: prevLine.words.length - 1,\n          word: prevLine.words[prevLine.words.length - 1]\n        }\n      }\n    }\n    return null\n  }\n\n  private getNextWord(lineIndex: number, wordIndex: number): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    const currentLine = this.lyrics[lineIndex]\n    if (wordIndex < currentLine.words.length - 1) {\n      return {\n        lineIndex,\n        wordIndex: wordIndex + 1,\n        word: currentLine.words[wordIndex + 1]\n      }\n    } else if (lineIndex < this.lyrics.length - 1) {\n      const nextLine = this.lyrics[lineIndex + 1]\n      if (nextLine.words.length > 0) {\n        return {\n          lineIndex: lineIndex + 1,\n          wordIndex: 0,\n          word: nextLine.words[0]\n        }\n      }\n    }\n    return null\n  }\n\n  private finalizeWordTiming(\n    wordRef: { lineIndex: number, wordIndex: number, word: WordTiming },\n    actualDuration: number,\n    endTimestamp: number\n  ): void {\n    const { word } = wordRef\n\n    word.endTime = endTimestamp\n    word.duration = actualDuration\n\n    // Distribute syllable timing\n    this.distributeSyllableTiming(word, actualDuration)\n\n    this.log('WORD_FINALIZED', endTimestamp, wordRef.lineIndex, wordRef.wordIndex, undefined,\n      `${word.word} (${actualDuration}ms)`)\n  }\n\n  private distributeSyllableTiming(word: WordTiming, totalDuration: number): void {\n    if (word.syllables.length <= 1) {\n      // Single syllable gets full duration\n      if (word.syllables[0] && word.startTime !== undefined) {\n        word.syllables[0].startTime = word.startTime\n        word.syllables[0].endTime = word.startTime + totalDuration\n        word.syllables[0].duration = totalDuration\n      }\n      return\n    }\n\n    // Multiple syllables - use weighted distribution\n    const weights = word.syllables.map((_, index) => {\n      if (index === 0) return this.config.syllableWeights.first\n      if (index === word.syllables.length - 1) return this.config.syllableWeights.last\n      return this.config.syllableWeights.middle\n    })\n\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n    const syllableDurations = weights.map(weight => (weight / totalWeight) * totalDuration)\n\n    let currentTime = word.startTime!\n    word.syllables.forEach((syllable, index) => {\n      syllable.startTime = currentTime\n      syllable.endTime = currentTime + syllableDurations[index]\n      syllable.duration = syllableDurations[index]\n      currentTime = syllable.endTime\n\n      this.log('SYLLABLE_TIMED', syllable.startTime, -1, -1, index,\n        `${syllable.syllable} (${syllableDurations[index].toFixed(1)}ms)`)\n    })\n  }\n\n  private detectGap(text: string, previousDuration: number): number {\n    // Look at punctuation and word patterns to estimate gaps\n    if (text.includes(',') || text.includes(';')) {\n      return this.config.gaps.shortPause\n    } else if (text.includes('.') || text.includes('!') || text.includes('?')) {\n      return this.config.gaps.mediumPause\n    } else if (previousDuration > this.config.minimums.wordDuration * 2) {\n      // Previous word was held long - likely end of phrase\n      return this.config.gaps.mediumPause\n    }\n\n    return 0 // No gap detected\n  }\n\n  private findLastTimedWord(): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    for (let lineIndex = this.lyrics.length - 1; lineIndex >= 0; lineIndex--) {\n      const line = this.lyrics[lineIndex]\n      for (let wordIndex = line.words.length - 1; wordIndex >= 0; wordIndex--) {\n        const word = line.words[wordIndex]\n        if (word.startTime !== undefined) {\n          return {\n            lineIndex, wordIndex, word\n          }\n        }\n      }\n    }\n    return null\n  }\n\n  private estimateWordDuration(word: WordTiming): number {\n    // Simple estimation based on syllable count and word length\n    const syllableCount = word.syllables.length\n    const baseTime = this.config.minimums.wordDuration\n    return baseTime + (syllableCount - 1) * this.config.minimums.syllableDuration\n  }\n\n  private findCurrentSyllable(word: WordTiming, timestamp: number): number {\n    // Check if syllables have timing (word has been finalized)\n    const hasTimedSyllables = word.syllables.some(s => s.startTime !== undefined && s.endTime !== undefined)\n\n    if (hasTimedSyllables) {\n      // Use actual syllable timing\n      for (let i = 0; i < word.syllables.length; i++) {\n        const syllable = word.syllables[i]\n        if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n          // Use < instead of <= for endTime to ensure proper syllable transitions\n          // At exactly the boundary time, we should move to the next syllable\n          if (timestamp >= syllable.startTime && timestamp < syllable.endTime) {\n            return i\n          }\n        }\n      }\n      // If we're past all syllables, return the last valid syllable index\n      return Math.max(0, word.syllables.length - 1)\n    } else {\n      // Word hasn't been finalized yet - estimate syllable timing on-the-fly\n      if (word.startTime === undefined || word.syllables.length <= 1) {\n        return 0\n      }\n\n      // Estimate which syllable should be active based on elapsed time\n      const elapsedTime = timestamp - word.startTime\n\n      // Use a simple progression: each syllable gets a minimum duration\n      // Find which syllable we should be in based on time thresholds\n      for (let i = 0; i < word.syllables.length; i++) {\n        const minTimeForThisSyllable = (i + 1) * this.config.minimums.syllableDuration\n\n        // If we haven't reached the time threshold for this syllable, return previous\n        if (elapsedTime < minTimeForThisSyllable) {\n          return Math.max(0, i)\n        }\n      }\n\n      // If we're well into the word, return the last syllable\n      return word.syllables.length - 1\n\n      // If we're well into the word, return the last syllable\n      return word.syllables.length - 1\n    }\n  }\n\n  private log(event: string, timestamp: number, lineIndex: number, wordIndex?: number, syllableIndex?: number, details?: string): void {\n    const logEntry = `[${timestamp.toFixed(0).padStart(6)}ms] ${event.padEnd(20)} L:${lineIndex.toString().padStart(2)} W:${(wordIndex ?? -1).toString().padStart(2)} S:${(syllableIndex ?? -1).toString().padStart(2)} ${details || ''}`\n\n    // Only log to console if not in silent mode (still store in eventLog for testing)\n    if (!this.silent) {\n      console.log(logEntry)\n    }\n\n    // Also store structured events for testing\n    this.eventLog.push({\n      type: event as any,\n      timestamp,\n      lineIndex,\n      wordIndex,\n      syllableIndex,\n      text: details\n    })\n  }\n}\n","/**\n * TIMING CONSTANTS - Central Configuration for All Timing Rules\n *\n * This is the single source of truth for all timing-related constants\n * used throughout the karaoke composer. All components and models should\n * consume these values instead of hardcoding their own.\n *\n * =====================================================\n * SYLLABLE DURATION RATIONALE - 50ms Minimum Analysis\n * =====================================================\n *\n * The 50ms minimum syllable duration has been validated across musical tempos:\n *\n * TEMPO ANALYSIS:\n * • Ballad (40-60 BPM):   50ms = 3-5% of beat,  allows 20-30 syllables/beat\n * • Mid-tempo (80-120 BPM): 50ms = 7-10% of beat, allows 10-15 syllables/beat\n * • Fast (144+ BPM):     50ms = 12% of beat,    allows 8+ syllables/beat\n *\n * HUMAN SPEECH CONTEXT:\n * • Normal speech syllables: 150-200ms (50ms is 25-33% of normal)\n * • Fast speech syllables: 80-120ms (50ms is 42-63% of fast speech)\n * • Rap/fast singing: 50-80ms (50ms matches lower bound of performance)\n * • Physical tongue/vocal limit: ~40ms (50ms provides safe margin)\n *\n * TECHNICAL CONSTRAINTS:\n * • Human audio perception: 20-30ms threshold (50ms is well above)\n * • Audio processing frames: ~23ms typical (50ms allows 2+ frames)\n * • Karaoke highlight flicker: 40-50ms threshold (50ms prevents flicker)\n *\n * CONCLUSION: 50ms provides excellent balance between:\n * - Musical flexibility (leaves 88-97% of beat time for expression)\n * - Technical safety (prevents UI flicker and audio artifacts)\n * - Performance realism (matches fast singing capabilities)\n * - Editor usability (prevents accidentally tiny syllables)\n */\n\nexport interface TimingRules {\n  // Word-level constraints\n  word: {\n    minDuration: number          // Minimum word duration (ms)\n    maxDuration: number          // Maximum reasonable word duration (ms)\n    collisionMargin: number      // Space between words to prevent overlap (ms)\n    defaultDuration: number      // Fallback duration when no timing available (ms)\n  }\n\n  // Syllable-level constraints\n  syllable: {\n    minDuration: number          // Minimum syllable duration for editor safety (ms)\n    defaultDuration: number      // Default syllable duration (ms)\n    lastSyllableWeight: number   // Multiplier for last syllable in weighted distribution\n    firstSyllableWeight: number  // Weight for first syllables\n    weightIncrement: number      // How much weight increases per syllable position\n  }\n\n  // Auto-timing behavior\n  autoTiming: {\n    normalWordSpacing: number    // Percentage of gap to use for normal words (0.0-1.0)\n    phraseBreakSpacing: number   // Percentage of gap to use for phrase breaks (0.0-1.0)\n    phraseBreakThreshold: number // Gap duration (seconds) that indicates phrase break\n    maxNormalDuration: number    // Max duration for normal spacing (ms)\n    maxPhraseBreakDuration: number // Max duration for phrase breaks (ms)\n    conservativeGapUsage: number // Percentage of gap for syllable distribution (0.0-1.0)\n    lineEndingGapUsage: number   // Percentage of gap for line-ending words (0.0-1.0)\n  }\n\n  // Musical timing intelligence\n  musical: {\n    restDuration: {\n      comma: number              // Rest after comma (ms)\n      period: number             // Rest after period/sentence (ms)\n      breath: number             // Natural breathing pause (ms)\n      phrase: number             // Phrase/verse break (ms)\n    }\n    notePatterns: {\n      eighth: number             // Eighth note duration base (ms)\n      quarter: number            // Quarter note duration base (ms)\n      half: number               // Half note duration base (ms)\n      whole: number              // Whole note duration base (ms)\n    }\n    conservativeMultiplier: number // When preserving timing, max percentage of gap to use\n  }\n\n  // Editor constraints\n  editor: {\n    pixelThreshold: number       // Minimum pixels for drag operations\n    snapThreshold: number        // Time threshold for snapping operations (ms)\n    viewportBuffer: number       // Buffer space at viewport edges (ms)\n    dragSensitivity: number      // Mouse movement sensitivity\n  }\n\n  // Validation and cleanup\n  validation: {\n    gapTolerance: number         // Max gap to auto-fix between syllables (ms)\n    overlapTolerance: number     // Max overlap to auto-fix between syllables (ms)\n    durationTolerance: number    // Tolerance for duration matching (ms)\n    timingPrecision: number      // Rounding precision for timing values (ms)\n  }\n\n  // Visual refresh and update rates\n  refresh: {\n    playbackUpdateHz: number     // Playback position update frequency (Hz)\n    fastModeMultiplier: number   // Multiplier for faster refresh mode\n    dragUpdateHz: number         // UI update frequency during drag operations (Hz)\n  }\n}\n\n/**\n * DEFAULT TIMING RULES - Carefully tuned values\n * These can be overridden in specific contexts, but provide sensible defaults\n */\nexport const DEFAULT_TIMING_RULES: TimingRules = {\n  word: {\n    minDuration: 100,            // 100ms minimum - shorter words feel too rushed\n    maxDuration: 2000,           // 2 seconds max - longer words feel unnatural\n    collisionMargin: 50,         // 50ms gap between words prevents overlap issues\n    defaultDuration: 500,        // 500ms default when no better info available\n  },\n\n  syllable: {\n    minDuration: 50,             // 50ms minimum - editor safety constraint\n    defaultDuration: 200,        // 200ms reasonable syllable duration\n    lastSyllableWeight: 2.0,     // Last syllable gets double time (musical)\n    firstSyllableWeight: 0.8,    // First syllables slightly shorter\n    weightIncrement: 0.1,        // Each syllable gets 10% more weight than previous\n  },\n\n  autoTiming: {\n    normalWordSpacing: 0.6,      // Use 60% of gap for normal words (was 82.5%)\n    phraseBreakSpacing: 0.25,    // Use 25% of gap for phrase breaks (was 50%)\n    phraseBreakThreshold: 3.0,   // 3+ second gaps indicate phrase breaks\n    maxNormalDuration: 600,      // Cap normal words at 600ms\n    maxPhraseBreakDuration: 800, // Cap phrase break words at 800ms\n    conservativeGapUsage: 0.7,   // Use 70% of gap for syllable distribution\n    lineEndingGapUsage: 0.5,     // Use 50% of gap for line-ending words\n  },\n\n  musical: {\n    restDuration: {\n      comma: 200,                // 200ms pause after comma\n      period: 800,               // 800ms pause after sentence\n      breath: 300,               // 300ms natural breath\n      phrase: 600,               // 600ms phrase break\n    },\n    notePatterns: {\n      eighth: 125,               // Eighth note ~120 BPM\n      quarter: 250,              // Quarter note ~120 BPM\n      half: 500,                 // Half note ~120 BPM\n      whole: 1000,               // Whole note ~120 BPM\n    },\n    conservativeMultiplier: 0.7, // Max 70% of gap when preserving timing\n  },\n\n  editor: {\n    pixelThreshold: 5,           // 5px minimum drag movement\n    snapThreshold: 10,           // 10ms snap threshold\n    viewportBuffer: 100,         // 100ms buffer at edges\n    dragSensitivity: 1.0,        // Normal drag sensitivity\n  },\n\n  validation: {\n    gapTolerance: 3,             // Auto-fix gaps up to 3ms\n    overlapTolerance: 3,         // Auto-fix overlaps up to 3ms\n    durationTolerance: 1,        // 1ms tolerance for duration matching\n    timingPrecision: 1,          // Round to nearest 1ms\n  },\n\n  refresh: {\n    playbackUpdateHz: 8,         // 8 Hz = 125ms intervals (2x faster than HTML5 default)\n    fastModeMultiplier: 1.5,     // 1.5x faster = 12 Hz for fast mode\n    dragUpdateHz: 60,            // 60 Hz for smooth drag operations (requestAnimationFrame)\n  }\n}\n\n/**\n * TIMING CONSTANTS - Global instance\n * Import and use this throughout the application\n */\nexport const TIMING = DEFAULT_TIMING_RULES\n\n/**\n * Utility functions for common timing calculations\n */\nexport class TimingUtils {\n  /**\n   * Calculate syllable weights for a given count\n   */\n  static calculateSyllableWeights(syllableCount: number): number[] {\n    return Array.from({ length: syllableCount }, (_, i) => {\n      if (i === syllableCount - 1) {\n        return TIMING.syllable.lastSyllableWeight\n      }\n      return TIMING.syllable.firstSyllableWeight + i * TIMING.syllable.weightIncrement\n    })\n  }\n\n  /**\n   * Determine if a gap indicates a phrase break\n   */\n  static isPhraseBreak(gapSeconds: number): boolean {\n    return gapSeconds > TIMING.autoTiming.phraseBreakThreshold\n  }\n\n  /**\n   * Calculate conservative duration from full gap\n   */\n  static getConservativeDuration(fullGap: number, isLineEnding: boolean = false): number {\n    const usage = isLineEnding ? TIMING.autoTiming.lineEndingGapUsage : TIMING.autoTiming.conservativeGapUsage\n    return fullGap * usage\n  }\n\n  /**\n   * Validate and constrain duration to reasonable bounds\n   */\n  static constrainDuration(duration: number, isWord: boolean = true): number {\n    const min = isWord ? TIMING.word.minDuration : TIMING.syllable.minDuration\n    const max = isWord ? TIMING.word.maxDuration : TIMING.word.maxDuration / 2 // Syllables max half word duration\n    return Math.max(min, Math.min(max, duration))\n  }\n\n  /**\n   * Round timing value to configured precision\n   */\n  static roundTiming(value: number): number {\n    return Math.round(value / TIMING.validation.timingPrecision) * TIMING.validation.timingPrecision\n  }\n\n  /**\n   * Get playback update interval in milliseconds\n   */\n  static getPlaybackUpdateInterval(fastMode: boolean = false): number {\n    const hz = fastMode\n      ? TIMING.refresh.playbackUpdateHz * TIMING.refresh.fastModeMultiplier\n      : TIMING.refresh.playbackUpdateHz\n    return 1000 / hz\n  }\n\n  /**\n   * Get drag update interval in milliseconds\n   */\n  static getDragUpdateInterval(): number {\n    return 1000 / TIMING.refresh.dragUpdateHz\n  }\n}\n\n/**\n * Export common timing constants for quick access\n */\nexport const {\n  word: WORD_TIMING,\n  syllable: SYLLABLE_TIMING,\n  autoTiming: AUTO_TIMING,\n  musical: MUSICAL_TIMING,\n  editor: EDITOR_TIMING,\n  validation: VALIDATION_TIMING\n} = TIMING\n","// Utility functions for parsing lyrics with syllable markers\nimport type { LyricLine, WordTiming, SyllableTiming, LyricsMetadata } from '@/types/karaoke'\nimport { KaraokeTimingEngine } from '@/models/KaraokeTimingEngine'\nimport { TIMING, TimingUtils } from '@/models/TimingConstants'\n\n/**\n * Parse a line of text with syllable markers (/) into structured word/syllable data\n * Example: \"Hel/lo world a/maz/ing\" -> [{ word: \"Hello\", syllables: [\"Hel\", \"lo\"] }, ...]\n */\nexport function parseLyricsLine(text: string, lineNumber: number, lineId: string): LyricLine {\n  const words: WordTiming[] = []\n\n  // Split by spaces to get words\n  const wordTexts = text.split(/\\s+/).filter(word => word.length > 0)\n\n  wordTexts.forEach((wordText) => {\n    // Split word by \"/\" to get syllables\n    const syllableTexts = wordText.split('/').filter(syl => syl.length > 0)\n\n    const syllables: SyllableTiming[] = syllableTexts.map((syllableText) => ({\n      syllable: syllableText,\n      // startTime, endTime, duration will be added during timing\n    }))\n\n    // Reconstruct the full word without syllable markers\n    const fullWord = syllableTexts.join('')\n\n    words.push({\n      word: fullWord,\n      syllables: syllables,\n      // startTime, endTime, duration will be added during timing\n    })\n  })\n\n  return {\n    id: lineId,\n    lineNumber: lineNumber,\n    text: text, // Keep original text with markers\n    words: words,\n    // startTime, endTime, duration will be added during timing\n  }\n}\n\n/**\n * Convert structured lyrics back to text with syllable markers\n */\nexport function lyricLineToText(lyricLine: LyricLine): string {\n  return lyricLine.words\n    .map(word => {\n      if (word.syllables.length <= 1) {\n        return word.word\n      } else {\n        return word.syllables.map(syl => syl.syllable).join('/')\n      }\n    })\n    .join(' ')\n}\n\n/**\n * Parse multiple lines of lyrics text\n */\nexport function parseLyricsText(lyricsText: string): LyricLine[] {\n  if (!lyricsText || typeof lyricsText !== 'string') {\n    return []\n  }\n\n  const lines = lyricsText.split('\\n').filter(line => line.trim().length > 0)\n\n  return lines.map((line, index) => parseLyricsLine(line.trim(), index + 1, `line-${Date.now()}-${index}`))\n}\n\n/**\n * Find the current word/syllable based on playback time\n * Uses our improved KaraokeTimingEngine for accurate detection\n */\nexport function getCurrentPosition(\n  lyrics: LyricLine[],\n  currentTime: number\n): {\n  lineIndex: number\n  wordIndex: number\n  syllableIndex: number\n  line?: LyricLine\n  word?: WordTiming\n  syllable?: SyllableTiming\n} {\n  // Use our improved timing engine for position detection\n  const engine = new KaraokeTimingEngine({ silent: true })\n  engine.loadLyrics(lyrics)\n\n  const position = engine.getCurrentPosition(currentTime)\n\n  // Return compatible format with additional line/word/syllable objects\n  const result = {\n    lineIndex: position.lineIndex,\n    wordIndex: position.wordIndex,\n    syllableIndex: position.syllableIndex,\n    line: undefined as LyricLine | undefined,\n    word: undefined as WordTiming | undefined,\n    syllable: undefined as SyllableTiming | undefined\n  }\n\n  // Add the actual objects if position is valid and active\n  if (position.isActive && position.lineIndex < lyrics.length) {\n    const line = lyrics[position.lineIndex]\n    result.line = line\n\n    if (position.wordIndex < line.words.length) {\n      const word = line.words[position.wordIndex]\n      result.word = word\n\n      if (position.syllableIndex < word.syllables.length) {\n        result.syllable = word.syllables[position.syllableIndex]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Assign timing to a word (spacebar functionality)\n */\nexport function assignWordTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  startTime: number,\n  estimatedWordDuration: number = 500 // Default 500ms per word\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex]) {\n    const word = line.words[wordIndex]\n    word.startTime = startTime\n    word.endTime = startTime + estimatedWordDuration\n    word.duration = estimatedWordDuration\n\n    // DON'T assign syllable timing yet - defer until we know actual word duration\n    // This will be calculated later when the next word gets its timing\n    // For now, just clear any existing syllable timing\n    word.syllables.forEach((syllable) => {\n      syllable.startTime = undefined\n      syllable.endTime = undefined\n      syllable.duration = undefined\n    })\n\n    // Now recalculate syllable timing for the PREVIOUS word if it exists\n    // Use CONSERVATIVE duration to prevent syllables from spilling into gaps\n    if (wordIndex > 0) {\n      const prevWord = line.words[wordIndex - 1]\n      if (prevWord.startTime !== undefined) {\n        const fullGap = startTime - prevWord.startTime\n        // Use centralized conservative gap usage rules\n        const conservativeDuration = TimingUtils.getConservativeDuration(fullGap, false)\n        distributeSyllableTiming(prevWord, prevWord.startTime, conservativeDuration)\n      }\n    } else if (lineIndex > 0) {\n      // Check previous line's last word\n      const prevLine = updatedLyrics[lineIndex - 1]\n      if (prevLine && prevLine.words.length > 0) {\n        const lastWordOfPrevLine = prevLine.words[prevLine.words.length - 1]\n        if (lastWordOfPrevLine.startTime !== undefined) {\n          const fullGap = startTime - lastWordOfPrevLine.startTime\n          // Use centralized line-ending gap usage rules\n          const conservativeDuration = TimingUtils.getConservativeDuration(fullGap, true)\n          distributeSyllableTiming(lastWordOfPrevLine, lastWordOfPrevLine.startTime, conservativeDuration)\n        }\n      }\n    }\n\n    // Update line timing\n    updateLineTiming(line)\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Distribute syllable timing within a word based on actual duration\n */\nfunction distributeSyllableTiming(word: WordTiming, wordStartTime: number, actualDuration: number) {\n  if (word.syllables.length <= 1) {\n    // Single syllable gets full word timing\n    if (word.syllables[0]) {\n      word.syllables[0].startTime = wordStartTime\n      word.syllables[0].endTime = wordStartTime + actualDuration\n      word.syllables[0].duration = actualDuration\n    }\n  } else {\n    // Multiple syllables - use centralized timing rules for smart distribution\n    const syllableCount = word.syllables.length\n    const totalMinDuration = TIMING.syllable.minDuration * syllableCount\n\n    if (actualDuration < totalMinDuration) {\n      // Duration too short for safe syllable distribution - extend the word\n      console.warn(`⚠️ Word \"${word.word}\" duration (${actualDuration}ms) too short for ${syllableCount} syllables. Extending to ${totalMinDuration}ms`)\n      actualDuration = totalMinDuration\n    }\n\n    // Use centralized syllable weighting system\n    const weights = TimingUtils.calculateSyllableWeights(syllableCount)\n\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n    const availableDuration = actualDuration - totalMinDuration // Extra duration to distribute\n\n    let currentTime = wordStartTime\n    word.syllables.forEach((syllable, index) => {\n      const baseMinDuration = TIMING.syllable.minDuration\n      const extraDuration = (weights[index] / totalWeight) * availableDuration\n      const syllableDuration = TimingUtils.constrainDuration(baseMinDuration + extraDuration, false)\n\n      syllable.startTime = currentTime\n      syllable.endTime = currentTime + syllableDuration\n      syllable.duration = syllableDuration\n      currentTime = syllable.endTime\n    })\n  }\n\n  // Update word timing to match actual duration\n  word.endTime = wordStartTime + actualDuration\n  word.duration = actualDuration\n}\n\n/**\n * Finalize syllable timing for words that don't have a next word to define their end time\n * This should be called for the last word in a line/song or when timing is complete\n */\nexport function finalizePendingSyllableTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  estimatedDuration: number = 500\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex]) {\n    const word = line.words[wordIndex]\n    if (word.startTime !== undefined && word.syllables.some(s => s.startTime === undefined)) {\n      // This word has no syllable timing yet, finalize it with estimated duration\n      distributeSyllableTiming(word, word.startTime, estimatedDuration)\n    }\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Assign timing to a specific syllable (manual adjustment)\n */\nexport function assignSyllableTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  syllableIndex: number,\n  startTime: number,\n  duration: number\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex] && line.words[wordIndex].syllables[syllableIndex]) {\n    const syllable = line.words[wordIndex].syllables[syllableIndex]\n    syllable.startTime = startTime\n    syllable.endTime = startTime + duration\n    syllable.duration = duration\n\n    // Update word timing based on syllables\n    updateWordTiming(line.words[wordIndex])\n\n    // Update line timing\n    updateLineTiming(line)\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Update word timing based on syllable timings\n */\nfunction updateWordTiming(word: WordTiming): void {\n  const timedSyllables = word.syllables.filter(syl => syl.startTime !== undefined && syl.endTime !== undefined)\n\n  if (timedSyllables.length > 0) {\n    const startTimes = timedSyllables.map(syl => syl.startTime!).filter(t => t !== undefined)\n    const endTimes = timedSyllables.map(syl => syl.endTime!).filter(t => t !== undefined)\n\n    word.startTime = Math.min(...startTimes)\n    word.endTime = Math.max(...endTimes)\n    word.duration = word.endTime - word.startTime\n  }\n}\n\n/**\n * Update line timing based on word timings\n */\nfunction updateLineTiming(line: LyricLine): void {\n  const timedWords = line.words.filter(word => word.startTime !== undefined && word.endTime !== undefined)\n\n  if (timedWords.length > 0) {\n    const startTimes = timedWords.map(word => word.startTime!).filter(t => t !== undefined)\n    const endTimes = timedWords.map(word => word.endTime!).filter(t => t !== undefined)\n\n    line.startTime = Math.min(...startTimes)\n    line.endTime = Math.max(...endTimes)\n    line.duration = line.endTime - line.startTime\n  }\n}\n\n/**\n * Calculate completion statistics\n */\nexport function getTimingStats(lyrics: LyricLine[]): {\n  totalLines: number\n  timedLines: number\n  totalWords: number\n  timedWords: number\n  totalSyllables: number\n  timedSyllables: number\n  completionPercent: number\n} {\n  let totalWords = 0\n  let timedWords = 0\n  let totalSyllables = 0\n  let timedSyllables = 0\n  let timedLines = 0\n\n  lyrics.forEach(line => {\n    if (line.startTime !== undefined && line.endTime !== undefined) {\n      timedLines++\n    }\n\n    line.words.forEach(word => {\n      totalWords++\n      if (word.startTime !== undefined && word.endTime !== undefined) {\n        timedWords++\n      }\n\n      word.syllables.forEach(syllable => {\n        totalSyllables++\n        if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n          timedSyllables++\n        }\n      })\n    })\n  })\n\n  const completionPercent = totalSyllables > 0 ? Math.round((timedSyllables / totalSyllables) * 100) : 0\n\n  return {\n    totalLines: lyrics.length,\n    timedLines,\n    totalWords,\n    timedWords,\n    totalSyllables,\n    timedSyllables,\n    completionPercent,\n  }\n}\n\n/**\n * Check if a line contains metadata ([@TITLE:], [@AUTHOR:], [@CAPTION:])\n */\nexport function isMetadataLine(text: string): boolean {\n  return /^\\[@(TITLE|AUTHOR|CAPTION):.+\\]/.test(text.trim())\n}\n\n/**\n * Parse metadata from a line\n */\nexport function parseMetadataLine(text: string): {\n  type: 'title' | 'author' | 'caption'\n  value: string\n} | null {\n  const trimmed = text.trim()\n\n  const titleMatch = trimmed.match(/^\\[@TITLE:(.+)\\]/)\n  if (titleMatch) {\n    return {\n      type: 'title',\n      value: titleMatch[1].trim()\n    }\n  }\n\n  const authorMatch = trimmed.match(/^\\[@AUTHOR:(.+)\\]/)\n  if (authorMatch) {\n    return {\n      type: 'author',\n      value: authorMatch[1].trim()\n    }\n  }\n\n  const captionMatch = trimmed.match(/^\\[@CAPTION:(.+)\\]/)\n  if (captionMatch) {\n    return {\n      type: 'caption',\n      value: captionMatch[1].trim()\n    }\n  }\n\n  return null\n}\n\n/**\n * Parse lyrics text with metadata support\n */\nexport function parseLyricsWithMetadata(lyricsText: string): {\n  lyrics: LyricLine[]\n  metadata: LyricsMetadata\n} {\n  if (!lyricsText || typeof lyricsText !== 'string') {\n    return {\n      lyrics: [],\n      metadata: {}\n    }\n  }\n\n  const lines = lyricsText.split('\\n').map(line => line.trim()).filter(line => line.length > 0)\n  const lyrics: LyricLine[] = []\n  const metadata: LyricsMetadata = {}\n\n  let lyricsLineNumber = 1\n  let pendingCaption: string | null = null  // Store caption to attach to next lyrics line\n\n  // Process each line\n  lines.forEach((line, originalIndex) => {\n    const metadataInfo = parseMetadataLine(line)\n\n    if (metadataInfo) {\n      // Handle metadata lines\n      const metadataLine: LyricLine = {\n        id: `metadata-${originalIndex}`,\n        lineNumber: lyricsLineNumber,\n        text: line,\n        words: [],\n        type: metadataInfo.type,\n        metadata: { [metadataInfo.type]: metadataInfo.value }\n      }\n\n      // Store in metadata object for easy access\n      if (metadataInfo.type === 'title') {\n        metadata.title = metadataInfo.value\n      } else if (metadataInfo.type === 'author') {\n        metadata.author = metadataInfo.value\n      } else if (metadataInfo.type === 'caption') {\n        if (!metadata.captions) metadata.captions = []\n        metadata.captions.push(metadataInfo.value)\n        // Store caption to also attach to next lyrics line\n        pendingCaption = metadataInfo.value\n      }\n\n      lyrics.push(metadataLine)\n      lyricsLineNumber++\n    } else {\n      // Handle regular lyrics lines\n      const lyricLine = parseLyricsLine(line, lyricsLineNumber, `line-${lyricsLineNumber}`)\n      lyricLine.type = 'lyrics'\n\n      // Attach pending caption if exists (for export purposes)\n      if (pendingCaption) {\n        if (!lyricLine.metadata) {\n          lyricLine.metadata = {}\n        }\n        lyricLine.metadata.caption = pendingCaption\n        pendingCaption = null\n      }\n\n      lyrics.push(lyricLine)\n      lyricsLineNumber++\n    }\n  })  // Move title to first position if it exists but isn't first\n  const titleLineIndex = lyrics.findIndex(line => line.type === 'title')\n  if (titleLineIndex > 0) {\n    const titleLine = lyrics.splice(titleLineIndex, 1)[0]\n    lyrics.unshift(titleLine)\n    // Renumber all lines\n    lyrics.forEach((line, index) => {\n      line.lineNumber = index + 1\n    })\n  }\n\n  return {\n    lyrics,\n    metadata\n  }\n}\n\n/**\n * Clears timing data from a line and all subsequent lines to prevent inconsistencies\n * This ensures that timing data remains sequential and doesn't have gaps\n */\nexport function clearTimingFromLine(lyrics: LyricLine[], fromLineIndex: number): LyricLine[] {\n  const result = [...lyrics]\n\n  // Clear timing from the specified line and all subsequent lines\n  for (let lineIndex = fromLineIndex; lineIndex < result.length; lineIndex++) {\n    const line = result[lineIndex]\n\n    // Skip metadata lines - they don't have timing\n    if (line.type && line.type !== 'lyrics') {\n      continue\n    }\n\n    // Clear line-level timing\n    line.startTime = undefined\n    line.endTime = undefined\n    line.duration = undefined\n\n    // Clear word-level timing for all words in this line\n    if (line.words) {\n      line.words.forEach(word => {\n        word.startTime = undefined\n        word.endTime = undefined\n        word.duration = undefined\n\n        // Clear syllable-level timing for all syllables in this word\n        if (word.syllables) {\n          word.syllables.forEach(syllable => {\n            syllable.startTime = undefined\n            syllable.endTime = undefined\n            syllable.duration = undefined\n          })\n        }\n      })\n    }\n  }\n\n  return result\n}\n"],"names":["KaraokeTimingEngine","config","__publicField","lyrics","lineIndex","wordIndex","timestamp","events","word","previousWord","actualDuration","gap","endTimestamp","lastWord","estimatedDuration","line","syllableIndex","nextWord","totalWords","timedWords","totalSyllables","timedSyllables","totalDuration","syllable","prevLine","currentLine","nextLine","wordRef","weights","_","index","totalWeight","sum","weight","syllableDurations","currentTime","text","previousDuration","syllableCount","i","elapsedTime","minTimeForThisSyllable","event","details","logEntry","DEFAULT_TIMING_RULES","TIMING","TimingUtils","gapSeconds","fullGap","isLineEnding","usage","duration","isWord","min","max","value","fastMode","parseLyricsLine","lineNumber","lineId","words","wordText","syllableTexts","syl","syllables","syllableText","fullWord","getCurrentPosition","engine","position","result","assignWordTiming","startTime","estimatedWordDuration","updatedLyrics","prevWord","conservativeDuration","distributeSyllableTiming","lastWordOfPrevLine","updateLineTiming","wordStartTime","totalMinDuration","availableDuration","baseMinDuration","extraDuration","syllableDuration","finalizePendingSyllableTiming","s","startTimes","t","endTimes","getTimingStats","timedLines","completionPercent","parseMetadataLine","trimmed","titleMatch","authorMatch","captionMatch","parseLyricsWithMetadata","lyricsText","lines","metadata","lyricsLineNumber","pendingCaption","originalIndex","metadataInfo","metadataLine","lyricLine","titleLineIndex","titleLine","clearTimingFromLine","fromLineIndex"],"mappings":"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"}