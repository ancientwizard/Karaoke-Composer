{"version":3,"file":"audioStorageService-d4372df5.js","sources":["../../src/services/audioStorageService.ts"],"sourcesContent":["// Audio file storage service with multiple persistence strategies\nimport type { AudioFile } from '@/types/karaoke'\n\ninterface StoredAudioFile {\n  name: string\n  size: number\n  type: string\n  lastModified: number\n  storageType: 'base64' | 'indexeddb' | 'reference'\n  data?: string // base64 data\n  originalPath?: string // for reference storage\n  indexed_id?: string // for indexeddb storage\n}\n\ninterface AudioStorageOptions {\n  maxSizeForBase64: number // Max file size (in bytes) to store as base64\n  preferredMethod: 'base64' | 'indexeddb' | 'reference'\n}\n\nexport class AudioStorageService {\n  private dbName = 'KaraokeAudioFiles'\n  private dbVersion = 1\n  private storeName = 'audioFiles'\n  private db: IDBDatabase | null = null\n\n  private options: AudioStorageOptions = {\n    maxSizeForBase64: 1 * 1024 * 1024, // 1MB max for base64 (very safe)\n    preferredMethod: 'indexeddb', // IndexedDB can handle 4-5MB files easily\n  }\n\n  constructor() {\n    this.initIndexedDB()\n  }\n\n  private async initIndexedDB(): Promise<void> {\n    return new Promise((resolve) => {\n      if (!window.indexedDB) {\n        console.warn('IndexedDB not supported by browser')\n        resolve()\n        return\n      }\n\n      const request = indexedDB.open(this.dbName, this.dbVersion)\n\n      request.onerror = () => {\n        console.warn('IndexedDB initialization failed, falling back to other storage methods')\n        resolve()\n      }\n\n      request.onsuccess = () => {\n        this.db = request.result\n        console.log('IndexedDB initialized successfully - can handle large files!')\n        resolve()\n      }\n\n      request.onupgradeneeded = () => {\n        const db = request.result\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: 'id' })\n          console.log('IndexedDB object store created')\n        }\n      }\n    })\n  }\n\n  async storeAudioFile(file: File, projectId: string): Promise<StoredAudioFile> {\n    const audioId = `${projectId}_${file.name}_${file.lastModified}`\n\n    const fileSizeMB = file.size / 1024 / 1024\n    console.log(`Storing audio file: ${file.name} (${fileSizeMB.toFixed(2)}MB)`)\n\n    // Give user feedback for larger files\n    if (fileSizeMB > 3) {\n      console.log('Large file detected, using IndexedDB for optimal storage')\n    }\n\n    try {\n      // Try methods in order of preference\n\n      // 1. First try IndexedDB if available (best for larger files, no quota limits)\n      if (this.db) {\n        try {\n          console.log('Attempting IndexedDB storage (unlimited capacity)...')\n          return await this.storeInIndexedDB(file, audioId)\n        } catch (indexedError) {\n          console.warn('IndexedDB storage failed:', indexedError)\n        }\n      } else {\n        console.warn('IndexedDB not available - this may cause issues with larger files')\n      }\n\n      // 2. Try base64 for smaller files\n      if (file.size <= this.options.maxSizeForBase64) {\n        try {\n          console.log('Attempting base64 storage...')\n          return await this.storeAsBase64(file, audioId)\n        } catch (base64Error) {\n          if (base64Error instanceof Error && base64Error.message === 'QUOTA_EXCEEDED') {\n            console.warn('localStorage quota exceeded')\n            // Show user-friendly message\n            alert(\n              `⚠️ Browser Storage Full!\\n\\nFile \"${file.name}\" couldn't be saved due to storage quota limits.\\n\\n✅ Your project will still work, but you'll need to re-select the audio file when loading.\\n\\n💡 Tip: Use the \"Storage\" button to clear old audio cache or try smaller audio files.`\n            )\n          } else {\n            console.warn('Base64 storage failed:', base64Error)\n          }\n        }\n      }\n\n      // 3. Fallback to reference storage\n      console.log('Using reference storage as fallback')\n      return this.storeAsReference(file)\n    } catch (error) {\n      console.error('All storage methods failed:', error)\n      // Final fallback to reference storage\n      return this.storeAsReference(file)\n    }\n  }\n\n  private async storeAsBase64(file: File, audioId: string): Promise<StoredAudioFile> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n\n      reader.onload = () => {\n        try {\n          const base64Data = reader.result as string\n          const stored: StoredAudioFile = {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            lastModified: file.lastModified,\n            storageType: 'base64',\n            data: base64Data,\n          }\n\n          // Try to store in localStorage with quota error handling\n          const dataString = JSON.stringify(stored)\n\n          // Check if we have enough space (rough estimate)\n          const currentUsage = this.getLocalStorageUsage()\n          const estimatedSize = dataString.length * 2 // UTF-16 encoding\n\n          if (currentUsage + estimatedSize > 3 * 1024 * 1024) {\n            // 3MB safe limit (very conservative)\n            throw new Error('localStorage quota would be exceeded')\n          }\n\n          localStorage.setItem(`audio_${audioId}`, dataString)\n          console.log('Audio file stored as base64:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`)\n          resolve(stored)\n        } catch (error) {\n          if (\n            error instanceof Error &&\n            (error.name === 'QuotaExceededError' ||\n              error.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||\n              error.message.includes('quota'))\n          ) {\n            console.warn('localStorage quota exceeded, falling back to reference storage')\n            reject(new Error('QUOTA_EXCEEDED'))\n          } else {\n            reject(error)\n          }\n        }\n      }\n\n      reader.onerror = () => reject(reader.error)\n      reader.readAsDataURL(file)\n    })\n  }\n\n  private getLocalStorageUsage(): number {\n    let total = 0\n    for (const key in localStorage) {\n      if (Object.prototype.hasOwnProperty.call(localStorage, key)) {\n        total += localStorage[key].length * 2 // UTF-16 encoding\n      }\n    }\n    return total\n  }\n\n  private async storeInIndexedDB(file: File, audioId: string): Promise<StoredAudioFile> {\n    if (!this.db) {\n      throw new Error('IndexedDB database not initialized')\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite')\n        const store = transaction.objectStore(this.storeName)\n\n        const audioData = {\n          id: audioId,\n          name: file.name,\n          size: file.size,\n          type: file.type,\n          lastModified: file.lastModified,\n          file: file,\n        }\n\n        const request = store.put(audioData)\n\n        request.onsuccess = () => {\n          const stored: StoredAudioFile = {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            lastModified: file.lastModified,\n            storageType: 'indexeddb',\n            indexed_id: audioId,\n          }\n          console.log('✅ Audio file stored in IndexedDB:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`)\n          resolve(stored)\n        }\n\n        request.onerror = () => {\n          console.error('IndexedDB storage error:', request.error)\n          reject(new Error(`IndexedDB storage failed: ${request.error?.message || 'Unknown error'}`))\n        }\n\n        transaction.onerror = () => {\n          console.error('IndexedDB transaction error:', transaction.error)\n          reject(new Error(`IndexedDB transaction failed: ${transaction.error?.message || 'Unknown error'}`))\n        }\n      } catch (error) {\n        console.error('IndexedDB operation error:', error)\n        reject(error)\n      }\n    })\n  }\n\n  private storeAsReference(file: File): StoredAudioFile {\n    const stored: StoredAudioFile = {\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified,\n      storageType: 'reference',\n      originalPath: file.name, // We can't get the full path for security reasons\n    }\n\n    console.log('Audio file stored as reference:', file.name)\n    return stored\n  }\n\n  async retrieveAudioFile(storedFile: StoredAudioFile): Promise<AudioFile | null> {\n    try {\n      switch (storedFile.storageType) {\n        case 'base64':\n          return this.retrieveFromBase64(storedFile)\n\n        case 'indexeddb':\n          return await this.retrieveFromIndexedDB(storedFile)\n\n        case 'reference':\n          return await this.retrieveFromReference(storedFile)\n\n        default:\n          throw new Error(`Unknown storage type: ${storedFile.storageType}`)\n      }\n    } catch (error) {\n      console.error('Error retrieving audio file:', error)\n      return null\n    }\n  }\n\n  private retrieveFromBase64(storedFile: StoredAudioFile): AudioFile {\n    if (!storedFile.data) {\n      throw new Error('No base64 data found')\n    }\n\n    // Convert base64 back to blob\n    const byteCharacters = atob(storedFile.data.split(',')[1])\n    const byteNumbers = new Array(byteCharacters.length)\n\n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i)\n    }\n\n    const byteArray = new Uint8Array(byteNumbers)\n    const blob = new Blob([byteArray], { type: storedFile.type })\n    const file = new File([blob], storedFile.name, {\n      type: storedFile.type,\n      lastModified: storedFile.lastModified,\n    })\n\n    return {\n      name: storedFile.name,\n      file: file,\n      url: URL.createObjectURL(file),\n    }\n  }\n\n  private async retrieveFromIndexedDB(storedFile: StoredAudioFile): Promise<AudioFile> {\n    if (!this.db || !storedFile.indexed_id) {\n      throw new Error('IndexedDB not available or no ID provided')\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readonly')\n      const store = transaction.objectStore(this.storeName)\n      const request = store.get(storedFile.indexed_id!)\n\n      request.onsuccess = () => {\n        const result = request.result\n        if (result && result.file) {\n          resolve({\n            name: result.name,\n            file: result.file,\n            url: URL.createObjectURL(result.file),\n          })\n        } else {\n          reject(new Error('Audio file not found in IndexedDB'))\n        }\n      }\n\n      request.onerror = () => reject(request.error)\n    })\n  }\n\n  private async retrieveFromReference(storedFile: StoredAudioFile): Promise<AudioFile> {\n    // For reference storage, we need to prompt the user to re-select the file\n    return new Promise((resolve, reject) => {\n      const dialog = this.createFileSelectionDialog(storedFile)\n      document.body.appendChild(dialog)\n\n      const fileInput = dialog.querySelector('input[type=\"file\"]') as HTMLInputElement\n      const selectBtn = dialog.querySelector('.btn-primary') as HTMLButtonElement\n      const cancelBtn = dialog.querySelector('.btn-secondary') as HTMLButtonElement\n\n      selectBtn.addEventListener('click', () => {\n        const selectedFile = fileInput.files?.[0]\n        if (selectedFile) {\n          // Verify it's likely the same file\n          if (selectedFile.name === storedFile.name && Math.abs(selectedFile.size - storedFile.size) < 1024) {\n            resolve({\n              name: selectedFile.name,\n              file: selectedFile,\n              url: URL.createObjectURL(selectedFile),\n            })\n          } else {\n            const proceed = confirm(\n              `The selected file (${selectedFile.name}, ${(selectedFile.size / 1024 / 1024).toFixed(2)}MB) ` +\n              `doesn't exactly match the original (${storedFile.name}, ${(storedFile.size / 1024 / 1024).toFixed(2)}MB). ` +\n              'Use it anyway?'\n            )\n            if (proceed) {\n              resolve({\n                name: selectedFile.name,\n                file: selectedFile,\n                url: URL.createObjectURL(selectedFile),\n              })\n            } else {\n              reject(new Error('File selection cancelled'))\n            }\n          }\n        } else {\n          reject(new Error('No file selected'))\n        }\n        document.body.removeChild(dialog)\n      })\n\n      cancelBtn.addEventListener('click', () => {\n        document.body.removeChild(dialog)\n        reject(new Error('File selection cancelled'))\n      })\n    })\n  }\n\n  private createFileSelectionDialog(storedFile: StoredAudioFile): HTMLElement {\n    const dialog = document.createElement('div')\n    dialog.className = 'modal show'\n    dialog.style.display = 'block'\n    dialog.style.backgroundColor = 'rgba(0,0,0,0.5)'\n\n    dialog.innerHTML = `\n      <div class=\"modal-dialog\">\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <h5 class=\"modal-title\">🎵 Locate Audio File</h5>\n          </div>\n          <div class=\"modal-body\">\n            <p><strong>Missing audio file:</strong></p>\n            <div class=\"alert alert-info\">\n              <strong>File:</strong> ${storedFile.name}<br>\n              <strong>Size:</strong> ${(storedFile.size / 1024 / 1024).toFixed(2)} MB<br>\n              <strong>Type:</strong> ${storedFile.type}\n            </div>\n            <p>Please locate and select the original audio file to continue:</p>\n            <input type=\"file\" class=\"form-control\" accept=\"audio/*\">\n          </div>\n          <div class=\"modal-footer\">\n            <button type=\"button\" class=\"btn btn-secondary\">Cancel</button>\n            <button type=\"button\" class=\"btn btn-primary\">Use Selected File</button>\n          </div>\n        </div>\n      </div>\n    `\n\n    return dialog\n  }\n\n  async deleteAudioFile(storedFile: StoredAudioFile): Promise<void> {\n    try {\n      // Remove from localStorage\n      const keys = Object.keys(localStorage)\n\n      switch (storedFile.storageType) {\n        case 'base64':\n          for (const key of keys) {\n            if (key.startsWith('audio_') && localStorage.getItem(key)?.includes(storedFile.name)) {\n              localStorage.removeItem(key)\n              break\n            }\n          }\n          break\n\n        case 'indexeddb':\n          if (this.db && storedFile.indexed_id) {\n            const transaction = this.db.transaction([this.storeName], 'readwrite')\n            const store = transaction.objectStore(this.storeName)\n            store.delete(storedFile.indexed_id)\n          }\n          break\n\n        case 'reference':\n          // Nothing to delete for references\n          break\n      }\n      console.log('Audio file deleted:', storedFile.name)\n    } catch (error) {\n      console.error('Error deleting audio file:', error)\n    }\n  }\n\n  getStorageInfo(): { method: string; sizeMB: number; count: number; quotaUsedMB: number; quotaLimitMB: number } {\n    let sizeMB = 0\n    let count = 0\n\n    // Count base64 files in localStorage\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('audio_')) {\n        try {\n          const data = JSON.parse(localStorage.getItem(key) || '{}')\n          if (data.size) {\n            sizeMB += data.size / 1024 / 1024\n            count++\n          }\n        } catch (e) {\n          // Ignore invalid entries\n        }\n      }\n    })\n\n    const quotaUsedMB = this.getLocalStorageUsage() / 1024 / 1024\n    const quotaLimitMB = this.db ? 1000 : 10 // IndexedDB ~1GB limit, localStorage ~10MB\n\n    return {\n      method: this.db ? 'indexeddb' : this.options.preferredMethod,\n      sizeMB: Math.round(sizeMB * 100) / 100,\n      count,\n      quotaUsedMB: Math.round(quotaUsedMB * 100) / 100,\n      quotaLimitMB,\n    }\n  }\n\n  async clearOldAudioFiles(): Promise<number> {\n    let cleared = 0\n    const keysToRemove: string[] = []\n\n    // Find audio files in localStorage\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('audio_')) {\n        keysToRemove.push(key)\n      }\n    })\n\n    // Remove them\n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key)\n      cleared++\n    })\n\n    console.log(`Cleared ${cleared} audio files from localStorage`)\n    return cleared\n  }\n\n  setStorageOptions(options: Partial<AudioStorageOptions>): void {\n    this.options = {\n      ...this.options, ...options\n    }\n    console.log('Audio storage options updated:', this.options)\n  }\n\n  // Diagnostic method to test IndexedDB functionality\n  async testIndexedDBConnection(): Promise<{ available: boolean; error?: string; canStore: boolean }> {\n    const result = {\n      available: false, canStore: false, error: undefined as string | undefined\n    }\n\n    try {\n      // Check if IndexedDB exists\n      if (!window.indexedDB) {\n        result.error = 'IndexedDB not supported by browser'\n        return result\n      }\n\n      result.available = true\n\n      // Test if we can actually open our database\n      if (!this.db) {\n        await this.initIndexedDB()\n      }\n\n      if (this.db) {\n        result.canStore = true\n        console.log('✅ IndexedDB connection test successful')\n      } else {\n        result.error = 'Could not initialize IndexedDB database'\n      }\n    } catch (error) {\n      result.error = error instanceof Error ? error.message : 'Unknown IndexedDB error'\n    }\n\n    return result\n  }\n}\n\n// Export singleton instance\nexport const audioStorageService = new AudioStorageService()\n"],"names":["AudioStorageService","__publicField","resolve","request","db","file","projectId","audioId","fileSizeMB","indexedError","base64Error","error","reject","reader","base64Data","stored","dataString","currentUsage","estimatedSize","total","key","transaction","store","audioData","_a","storedFile","byteCharacters","byteNumbers","byteArray","blob","result","dialog","fileInput","selectBtn","cancelBtn","selectedFile","keys","sizeMB","count","data","e","quotaUsedMB","quotaLimitMB","cleared","keysToRemove","options","audioStorageService"],"mappings":"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"}