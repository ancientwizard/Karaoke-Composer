System.register([],function(e,o){"use strict";return{execute:function(){e("a",new class{dbName="KaraokeAudioFiles";dbVersion=1;storeName="audioFiles";db=null;options={maxSizeForBase64:1048576,preferredMethod:"indexeddb"};constructor(){this.initIndexedDB()}async initIndexedDB(){return new Promise(e=>{if(!window.indexedDB)return console.warn("IndexedDB not supported by browser"),void e();const o=indexedDB.open(this.dbName,this.dbVersion);o.onerror=()=>{console.warn("IndexedDB initialization failed, falling back to other storage methods"),e()},o.onsuccess=()=>{this.db=o.result,console.log("IndexedDB initialized successfully - can handle large files!"),e()},o.onupgradeneeded=()=>{const e=o.result;e.objectStoreNames.contains(this.storeName)||(e.createObjectStore(this.storeName,{keyPath:"id"}),console.log("IndexedDB object store created"))}})}async storeAudioFile(e,o){const t=`${o}_${e.name}_${e.lastModified}`,r=e.size/1024/1024;console.log(`Storing audio file: ${e.name} (${r.toFixed(2)}MB)`),r>3&&console.log("Large file detected, using IndexedDB for optimal storage");try{if(this.db)try{return console.log("Attempting IndexedDB storage (unlimited capacity)..."),await this.storeInIndexedDB(e,t)}catch(n){console.warn("IndexedDB storage failed:",n)}else console.warn("IndexedDB not available - this may cause issues with larger files");if(e.size<=this.options.maxSizeForBase64)try{return console.log("Attempting base64 storage..."),await this.storeAsBase64(e,t)}catch(a){a instanceof Error&&"QUOTA_EXCEEDED"===a.message?(console.warn("localStorage quota exceeded"),alert(`âš ï¸ Browser Storage Full!\n\nFile "${e.name}" couldn't be saved due to storage quota limits.\n\nâœ… Your project will still work, but you'll need to re-select the audio file when loading.\n\nðŸ’¡ Tip: Use the "Storage" button to clear old audio cache or try smaller audio files.`)):console.warn("Base64 storage failed:",a)}return console.log("Using reference storage as fallback"),this.storeAsReference(e)}catch(s){return console.error("All storage methods failed:",s),this.storeAsReference(e)}}async storeAsBase64(e,o){return new Promise((t,r)=>{const n=new FileReader;n.onload=()=>{try{const r=n.result,a={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"base64",data:r},s=JSON.stringify(a),i=this.getLocalStorageUsage();if(i+2*s.length>3145728)throw new Error("localStorage quota would be exceeded");localStorage.setItem(`audio_${o}`,s),console.log("Audio file stored as base64:",e.name,`(${(e.size/1024/1024).toFixed(2)}MB)`),t(a)}catch(a){a instanceof Error&&("QuotaExceededError"===a.name||"NS_ERROR_DOM_QUOTA_REACHED"===a.name||a.message.includes("quota"))?(console.warn("localStorage quota exceeded, falling back to reference storage"),r(new Error("QUOTA_EXCEEDED"))):r(a)}},n.onerror=()=>r(n.error),n.readAsDataURL(e)})}getLocalStorageUsage(){let e=0;for(const o in localStorage)Object.prototype.hasOwnProperty.call(localStorage,o)&&(e+=2*localStorage[o].length);return e}async storeInIndexedDB(e,o){if(!this.db)throw new Error("IndexedDB database not initialized");return new Promise((t,r)=>{try{const n=this.db.transaction([this.storeName],"readwrite"),a=n.objectStore(this.storeName),s={id:o,name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,file:e},i=a.put(s);i.onsuccess=()=>{const r={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"indexeddb",indexed_id:o};console.log("âœ… Audio file stored in IndexedDB:",e.name,`(${(e.size/1024/1024).toFixed(2)}MB)`),t(r)},i.onerror=()=>{console.error("IndexedDB storage error:",i.error),r(new Error(`IndexedDB storage failed: ${i.error?.message||"Unknown error"}`))},n.onerror=()=>{console.error("IndexedDB transaction error:",n.error),r(new Error(`IndexedDB transaction failed: ${n.error?.message||"Unknown error"}`))}}catch(n){console.error("IndexedDB operation error:",n),r(n)}})}storeAsReference(e){const o={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"reference",originalPath:e.name};return console.log("Audio file stored as reference:",e.name),o}async retrieveAudioFile(e){try{switch(e.storageType){case"base64":return this.retrieveFromBase64(e);case"indexeddb":return await this.retrieveFromIndexedDB(e);case"reference":return await this.retrieveFromReference(e);default:throw new Error(`Unknown storage type: ${e.storageType}`)}}catch(o){return console.error("Error retrieving audio file:",o),null}}retrieveFromBase64(e){if(!e.data)throw new Error("No base64 data found");const o=atob(e.data.split(",")[1]),t=new Array(o.length);for(let s=0;s<o.length;s++)t[s]=o.charCodeAt(s);const r=new Uint8Array(t),n=new Blob([r],{type:e.type}),a=new File([n],e.name,{type:e.type,lastModified:e.lastModified});return{name:e.name,file:a,url:URL.createObjectURL(a)}}async retrieveFromIndexedDB(e){if(!this.db||!e.indexed_id)throw new Error("IndexedDB not available or no ID provided");return new Promise((o,t)=>{const r=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(e.indexed_id);r.onsuccess=()=>{const e=r.result;e&&e.file?o({name:e.name,file:e.file,url:URL.createObjectURL(e.file)}):t(new Error("Audio file not found in IndexedDB"))},r.onerror=()=>t(r.error)})}async retrieveFromReference(e){return new Promise((o,t)=>{const r=this.createFileSelectionDialog(e);document.body.appendChild(r);const n=r.querySelector('input[type="file"]'),a=r.querySelector(".btn-primary"),s=r.querySelector(".btn-secondary");a.addEventListener("click",()=>{const a=n.files?.[0];a?a.name===e.name&&Math.abs(a.size-e.size)<1024||confirm(`The selected file (${a.name}, ${(a.size/1024/1024).toFixed(2)}MB) doesn't exactly match the original (${e.name}, ${(e.size/1024/1024).toFixed(2)}MB). Use it anyway?`)?o({name:a.name,file:a,url:URL.createObjectURL(a)}):t(new Error("File selection cancelled")):t(new Error("No file selected")),document.body.removeChild(r)}),s.addEventListener("click",()=>{document.body.removeChild(r),t(new Error("File selection cancelled"))})})}createFileSelectionDialog(e){const o=document.createElement("div");return o.className="modal show",o.style.display="block",o.style.backgroundColor="rgba(0,0,0,0.5)",o.innerHTML=`\n      <div class="modal-dialog">\n        <div class="modal-content">\n          <div class="modal-header">\n            <h5 class="modal-title">ðŸŽµ Locate Audio File</h5>\n          </div>\n          <div class="modal-body">\n            <p><strong>Missing audio file:</strong></p>\n            <div class="alert alert-info">\n              <strong>File:</strong> ${e.name}<br>\n              <strong>Size:</strong> ${(e.size/1024/1024).toFixed(2)} MB<br>\n              <strong>Type:</strong> ${e.type}\n            </div>\n            <p>Please locate and select the original audio file to continue:</p>\n            <input type="file" class="form-control" accept="audio/*">\n          </div>\n          <div class="modal-footer">\n            <button type="button" class="btn btn-secondary">Cancel</button>\n            <button type="button" class="btn btn-primary">Use Selected File</button>\n          </div>\n        </div>\n      </div>\n    `,o}async deleteAudioFile(e){try{const o=Object.keys(localStorage);switch(e.storageType){case"base64":for(const t of o)if(t.startsWith("audio_")&&localStorage.getItem(t)?.includes(e.name)){localStorage.removeItem(t);break}break;case"indexeddb":if(this.db&&e.indexed_id){const o=this.db.transaction([this.storeName],"readwrite");o.objectStore(this.storeName).delete(e.indexed_id)}}console.log("Audio file deleted:",e.name)}catch(o){console.error("Error deleting audio file:",o)}}getStorageInfo(){let e=0,o=0;Object.keys(localStorage).forEach(t=>{if(t.startsWith("audio_"))try{const r=JSON.parse(localStorage.getItem(t)||"{}");r.size&&(e+=r.size/1024/1024,o++)}catch(r){}});const t=this.getLocalStorageUsage()/1024/1024,r=this.db?1e3:10;return{method:this.db?"indexeddb":this.options.preferredMethod,sizeMB:Math.round(100*e)/100,count:o,quotaUsedMB:Math.round(100*t)/100,quotaLimitMB:r}}async clearOldAudioFiles(){let e=0;const o=[];return Object.keys(localStorage).forEach(e=>{e.startsWith("audio_")&&o.push(e)}),o.forEach(o=>{localStorage.removeItem(o),e++}),console.log(`Cleared ${e} audio files from localStorage`),e}setStorageOptions(e){this.options={...this.options,...e},console.log("Audio storage options updated:",this.options)}async testIndexedDBConnection(){const e={available:!1,canStore:!1,error:void 0};try{if(!window.indexedDB)return e.error="IndexedDB not supported by browser",e;e.available=!0,this.db||await this.initIndexedDB(),this.db?(e.canStore=!0,console.log("âœ… IndexedDB connection test successful")):e.error="Could not initialize IndexedDB database"}catch(o){e.error=o instanceof Error?o.message:"Unknown IndexedDB error"}return e}})}}});
//# sourceMappingURL=audioStorageService-legacy-297a1f4c.js.map
