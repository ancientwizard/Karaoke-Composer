var g=Object.defineProperty;var m=(c,e,t)=>e in c?g(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var l=(c,e,t)=>(m(c,typeof e!="symbol"?e+"":e,t),t);class h{constructor(){l(this,"dbName","KaraokeAudioFiles");l(this,"dbVersion",1);l(this,"storeName","audioFiles");l(this,"db",null);l(this,"options",{maxSizeForBase64:1*1024*1024,preferredMethod:"indexeddb"});this.initIndexedDB()}async initIndexedDB(){return new Promise(e=>{if(!window.indexedDB){console.warn("IndexedDB not supported by browser"),e();return}const t=indexedDB.open(this.dbName,this.dbVersion);t.onerror=()=>{console.warn("IndexedDB initialization failed, falling back to other storage methods"),e()},t.onsuccess=()=>{this.db=t.result,console.log("IndexedDB initialized successfully - can handle large files!"),e()},t.onupgradeneeded=()=>{const o=t.result;o.objectStoreNames.contains(this.storeName)||(o.createObjectStore(this.storeName,{keyPath:"id"}),console.log("IndexedDB object store created"))}})}async storeAudioFile(e,t){const o="".concat(t,"_").concat(e.name,"_").concat(e.lastModified),a=e.size/1024/1024;console.log("Storing audio file: ".concat(e.name," (").concat(a.toFixed(2),"MB)")),a>3&&console.log("Large file detected, using IndexedDB for optimal storage");try{if(this.db)try{return console.log("Attempting IndexedDB storage (unlimited capacity)..."),await this.storeInIndexedDB(e,o)}catch(r){console.warn("IndexedDB storage failed:",r)}else console.warn("IndexedDB not available - this may cause issues with larger files");if(e.size<=this.options.maxSizeForBase64)try{return console.log("Attempting base64 storage..."),await this.storeAsBase64(e,o)}catch(r){r instanceof Error&&r.message==="QUOTA_EXCEEDED"?(console.warn("localStorage quota exceeded"),alert('âš ï¸ Browser Storage Full!\n\nFile "'.concat(e.name,'" couldn\'t be saved due to storage quota limits.\n\nâœ… Your project will still work, but you\'ll need to re-select the audio file when loading.\n\nðŸ’¡ Tip: Use the "Storage" button to clear old audio cache or try smaller audio files.'))):console.warn("Base64 storage failed:",r)}return console.log("Using reference storage as fallback"),this.storeAsReference(e)}catch(r){return console.error("All storage methods failed:",r),this.storeAsReference(e)}}async storeAsBase64(e,t){return new Promise((o,a)=>{const r=new FileReader;r.onload=()=>{try{const n=r.result,i={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"base64",data:n},s=JSON.stringify(i),d=this.getLocalStorageUsage(),u=s.length*2;if(d+u>3*1024*1024)throw new Error("localStorage quota would be exceeded");localStorage.setItem("audio_".concat(t),s),console.log("Audio file stored as base64:",e.name,"(".concat((e.size/1024/1024).toFixed(2),"MB)")),o(i)}catch(n){n instanceof Error&&(n.name==="QuotaExceededError"||n.name==="NS_ERROR_DOM_QUOTA_REACHED"||n.message.includes("quota"))?(console.warn("localStorage quota exceeded, falling back to reference storage"),a(new Error("QUOTA_EXCEEDED"))):a(n)}},r.onerror=()=>a(r.error),r.readAsDataURL(e)})}getLocalStorageUsage(){let e=0;for(const t in localStorage)Object.prototype.hasOwnProperty.call(localStorage,t)&&(e+=localStorage[t].length*2);return e}async storeInIndexedDB(e,t){if(!this.db)throw new Error("IndexedDB database not initialized");return new Promise((o,a)=>{try{const r=this.db.transaction([this.storeName],"readwrite"),n=r.objectStore(this.storeName),i={id:t,name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,file:e},s=n.put(i);s.onsuccess=()=>{const d={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"indexeddb",indexed_id:t};console.log("âœ… Audio file stored in IndexedDB:",e.name,"(".concat((e.size/1024/1024).toFixed(2),"MB)")),o(d)},s.onerror=()=>{var d;console.error("IndexedDB storage error:",s.error),a(new Error("IndexedDB storage failed: ".concat(((d=s.error)==null?void 0:d.message)||"Unknown error")))},r.onerror=()=>{var d;console.error("IndexedDB transaction error:",r.error),a(new Error("IndexedDB transaction failed: ".concat(((d=r.error)==null?void 0:d.message)||"Unknown error")))}}catch(r){console.error("IndexedDB operation error:",r),a(r)}})}storeAsReference(e){const t={name:e.name,size:e.size,type:e.type,lastModified:e.lastModified,storageType:"reference",originalPath:e.name};return console.log("Audio file stored as reference:",e.name),t}async retrieveAudioFile(e){try{switch(e.storageType){case"base64":return this.retrieveFromBase64(e);case"indexeddb":return await this.retrieveFromIndexedDB(e);case"reference":return await this.retrieveFromReference(e);default:throw new Error("Unknown storage type: ".concat(e.storageType))}}catch(t){return console.error("Error retrieving audio file:",t),null}}retrieveFromBase64(e){if(!e.data)throw new Error("No base64 data found");const t=atob(e.data.split(",")[1]),o=new Array(t.length);for(let i=0;i<t.length;i++)o[i]=t.charCodeAt(i);const a=new Uint8Array(o),r=new Blob([a],{type:e.type}),n=new File([r],e.name,{type:e.type,lastModified:e.lastModified});return{name:e.name,file:n,url:URL.createObjectURL(n)}}async retrieveFromIndexedDB(e){if(!this.db||!e.indexed_id)throw new Error("IndexedDB not available or no ID provided");return new Promise((t,o)=>{const n=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(e.indexed_id);n.onsuccess=()=>{const i=n.result;i&&i.file?t({name:i.name,file:i.file,url:URL.createObjectURL(i.file)}):o(new Error("Audio file not found in IndexedDB"))},n.onerror=()=>o(n.error)})}async retrieveFromReference(e){return new Promise((t,o)=>{const a=this.createFileSelectionDialog(e);document.body.appendChild(a);const r=a.querySelector('input[type="file"]'),n=a.querySelector(".btn-primary"),i=a.querySelector(".btn-secondary");n.addEventListener("click",()=>{var d;const s=(d=r.files)==null?void 0:d[0];s?s.name===e.name&&Math.abs(s.size-e.size)<1024?t({name:s.name,file:s,url:URL.createObjectURL(s)}):confirm("The selected file (".concat(s.name,", ").concat((s.size/1024/1024).toFixed(2),"MB) doesn't exactly match the original (").concat(e.name,", ").concat((e.size/1024/1024).toFixed(2),"MB). Use it anyway?"))?t({name:s.name,file:s,url:URL.createObjectURL(s)}):o(new Error("File selection cancelled")):o(new Error("No file selected")),document.body.removeChild(a)}),i.addEventListener("click",()=>{document.body.removeChild(a),o(new Error("File selection cancelled"))})})}createFileSelectionDialog(e){const t=document.createElement("div");return t.className="modal show",t.style.display="block",t.style.backgroundColor="rgba(0,0,0,0.5)",t.innerHTML='\n      <div class="modal-dialog">\n        <div class="modal-content">\n          <div class="modal-header">\n            <h5 class="modal-title">ðŸŽµ Locate Audio File</h5>\n          </div>\n          <div class="modal-body">\n            <p><strong>Missing audio file:</strong></p>\n            <div class="alert alert-info">\n              <strong>File:</strong> '.concat(e.name,"<br>\n              <strong>Size:</strong> ").concat((e.size/1024/1024).toFixed(2)," MB<br>\n              <strong>Type:</strong> ").concat(e.type,'\n            </div>\n            <p>Please locate and select the original audio file to continue:</p>\n            <input type="file" class="form-control" accept="audio/*">\n          </div>\n          <div class="modal-footer">\n            <button type="button" class="btn btn-secondary">Cancel</button>\n            <button type="button" class="btn btn-primary">Use Selected File</button>\n          </div>\n        </div>\n      </div>\n    '),t}async deleteAudioFile(e){var t;try{const o=Object.keys(localStorage);switch(e.storageType){case"base64":for(const a of o)if(a.startsWith("audio_")&&((t=localStorage.getItem(a))!=null&&t.includes(e.name))){localStorage.removeItem(a);break}break;case"indexeddb":this.db&&e.indexed_id&&this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(e.indexed_id);break;case"reference":break}console.log("Audio file deleted:",e.name)}catch(o){console.error("Error deleting audio file:",o)}}getStorageInfo(){let e=0,t=0;Object.keys(localStorage).forEach(r=>{if(r.startsWith("audio_"))try{const n=JSON.parse(localStorage.getItem(r)||"{}");n.size&&(e+=n.size/1024/1024,t++)}catch(n){}});const o=this.getLocalStorageUsage()/1024/1024,a=this.db?1e3:10;return{method:this.db?"indexeddb":this.options.preferredMethod,sizeMB:Math.round(e*100)/100,count:t,quotaUsedMB:Math.round(o*100)/100,quotaLimitMB:a}}async clearOldAudioFiles(){let e=0;const t=[];return Object.keys(localStorage).forEach(o=>{o.startsWith("audio_")&&t.push(o)}),t.forEach(o=>{localStorage.removeItem(o),e++}),console.log("Cleared ".concat(e," audio files from localStorage")),e}setStorageOptions(e){this.options={...this.options,...e},console.log("Audio storage options updated:",this.options)}async testIndexedDBConnection(){const e={available:!1,canStore:!1,error:void 0};try{if(!window.indexedDB)return e.error="IndexedDB not supported by browser",e;e.available=!0,this.db||await this.initIndexedDB(),this.db?(e.canStore=!0,console.log("âœ… IndexedDB connection test successful")):e.error="Could not initialize IndexedDB database"}catch(t){e.error=t instanceof Error?t.message:"Unknown IndexedDB error"}return e}}const y=new h;export{y as a};
//# sourceMappingURL=audioStorageService-d4372df5.js.map
