{"version":3,"file":"audioStorageService-legacy-297a1f4c.js","sources":["../../src/services/audioStorageService.ts"],"sourcesContent":["// Audio file storage service with multiple persistence strategies\nimport type { AudioFile } from '@/types/karaoke'\n\ninterface StoredAudioFile {\n  name: string\n  size: number\n  type: string\n  lastModified: number\n  storageType: 'base64' | 'indexeddb' | 'reference'\n  data?: string // base64 data\n  originalPath?: string // for reference storage\n  indexed_id?: string // for indexeddb storage\n}\n\ninterface AudioStorageOptions {\n  maxSizeForBase64: number // Max file size (in bytes) to store as base64\n  preferredMethod: 'base64' | 'indexeddb' | 'reference'\n}\n\nexport class AudioStorageService {\n  private dbName = 'KaraokeAudioFiles'\n  private dbVersion = 1\n  private storeName = 'audioFiles'\n  private db: IDBDatabase | null = null\n\n  private options: AudioStorageOptions = {\n    maxSizeForBase64: 1 * 1024 * 1024, // 1MB max for base64 (very safe)\n    preferredMethod: 'indexeddb', // IndexedDB can handle 4-5MB files easily\n  }\n\n  constructor() {\n    this.initIndexedDB()\n  }\n\n  private async initIndexedDB(): Promise<void> {\n    return new Promise((resolve) => {\n      if (!window.indexedDB) {\n        console.warn('IndexedDB not supported by browser')\n        resolve()\n        return\n      }\n\n      const request = indexedDB.open(this.dbName, this.dbVersion)\n\n      request.onerror = () => {\n        console.warn('IndexedDB initialization failed, falling back to other storage methods')\n        resolve()\n      }\n\n      request.onsuccess = () => {\n        this.db = request.result\n        console.log('IndexedDB initialized successfully - can handle large files!')\n        resolve()\n      }\n\n      request.onupgradeneeded = () => {\n        const db = request.result\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: 'id' })\n          console.log('IndexedDB object store created')\n        }\n      }\n    })\n  }\n\n  async storeAudioFile(file: File, projectId: string): Promise<StoredAudioFile> {\n    const audioId = `${projectId}_${file.name}_${file.lastModified}`\n\n    const fileSizeMB = file.size / 1024 / 1024\n    console.log(`Storing audio file: ${file.name} (${fileSizeMB.toFixed(2)}MB)`)\n\n    // Give user feedback for larger files\n    if (fileSizeMB > 3) {\n      console.log('Large file detected, using IndexedDB for optimal storage')\n    }\n\n    try {\n      // Try methods in order of preference\n\n      // 1. First try IndexedDB if available (best for larger files, no quota limits)\n      if (this.db) {\n        try {\n          console.log('Attempting IndexedDB storage (unlimited capacity)...')\n          return await this.storeInIndexedDB(file, audioId)\n        } catch (indexedError) {\n          console.warn('IndexedDB storage failed:', indexedError)\n        }\n      } else {\n        console.warn('IndexedDB not available - this may cause issues with larger files')\n      }\n\n      // 2. Try base64 for smaller files\n      if (file.size <= this.options.maxSizeForBase64) {\n        try {\n          console.log('Attempting base64 storage...')\n          return await this.storeAsBase64(file, audioId)\n        } catch (base64Error) {\n          if (base64Error instanceof Error && base64Error.message === 'QUOTA_EXCEEDED') {\n            console.warn('localStorage quota exceeded')\n            // Show user-friendly message\n            alert(\n              `âš ï¸ Browser Storage Full!\\n\\nFile \"${file.name}\" couldn't be saved due to storage quota limits.\\n\\nâœ… Your project will still work, but you'll need to re-select the audio file when loading.\\n\\nðŸ’¡ Tip: Use the \"Storage\" button to clear old audio cache or try smaller audio files.`\n            )\n          } else {\n            console.warn('Base64 storage failed:', base64Error)\n          }\n        }\n      }\n\n      // 3. Fallback to reference storage\n      console.log('Using reference storage as fallback')\n      return this.storeAsReference(file)\n    } catch (error) {\n      console.error('All storage methods failed:', error)\n      // Final fallback to reference storage\n      return this.storeAsReference(file)\n    }\n  }\n\n  private async storeAsBase64(file: File, audioId: string): Promise<StoredAudioFile> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n\n      reader.onload = () => {\n        try {\n          const base64Data = reader.result as string\n          const stored: StoredAudioFile = {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            lastModified: file.lastModified,\n            storageType: 'base64',\n            data: base64Data,\n          }\n\n          // Try to store in localStorage with quota error handling\n          const dataString = JSON.stringify(stored)\n\n          // Check if we have enough space (rough estimate)\n          const currentUsage = this.getLocalStorageUsage()\n          const estimatedSize = dataString.length * 2 // UTF-16 encoding\n\n          if (currentUsage + estimatedSize > 3 * 1024 * 1024) {\n            // 3MB safe limit (very conservative)\n            throw new Error('localStorage quota would be exceeded')\n          }\n\n          localStorage.setItem(`audio_${audioId}`, dataString)\n          console.log('Audio file stored as base64:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`)\n          resolve(stored)\n        } catch (error) {\n          if (\n            error instanceof Error &&\n            (error.name === 'QuotaExceededError' ||\n              error.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||\n              error.message.includes('quota'))\n          ) {\n            console.warn('localStorage quota exceeded, falling back to reference storage')\n            reject(new Error('QUOTA_EXCEEDED'))\n          } else {\n            reject(error)\n          }\n        }\n      }\n\n      reader.onerror = () => reject(reader.error)\n      reader.readAsDataURL(file)\n    })\n  }\n\n  private getLocalStorageUsage(): number {\n    let total = 0\n    for (const key in localStorage) {\n      if (Object.prototype.hasOwnProperty.call(localStorage, key)) {\n        total += localStorage[key].length * 2 // UTF-16 encoding\n      }\n    }\n    return total\n  }\n\n  private async storeInIndexedDB(file: File, audioId: string): Promise<StoredAudioFile> {\n    if (!this.db) {\n      throw new Error('IndexedDB database not initialized')\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite')\n        const store = transaction.objectStore(this.storeName)\n\n        const audioData = {\n          id: audioId,\n          name: file.name,\n          size: file.size,\n          type: file.type,\n          lastModified: file.lastModified,\n          file: file,\n        }\n\n        const request = store.put(audioData)\n\n        request.onsuccess = () => {\n          const stored: StoredAudioFile = {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            lastModified: file.lastModified,\n            storageType: 'indexeddb',\n            indexed_id: audioId,\n          }\n          console.log('âœ… Audio file stored in IndexedDB:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`)\n          resolve(stored)\n        }\n\n        request.onerror = () => {\n          console.error('IndexedDB storage error:', request.error)\n          reject(new Error(`IndexedDB storage failed: ${request.error?.message || 'Unknown error'}`))\n        }\n\n        transaction.onerror = () => {\n          console.error('IndexedDB transaction error:', transaction.error)\n          reject(new Error(`IndexedDB transaction failed: ${transaction.error?.message || 'Unknown error'}`))\n        }\n      } catch (error) {\n        console.error('IndexedDB operation error:', error)\n        reject(error)\n      }\n    })\n  }\n\n  private storeAsReference(file: File): StoredAudioFile {\n    const stored: StoredAudioFile = {\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified,\n      storageType: 'reference',\n      originalPath: file.name, // We can't get the full path for security reasons\n    }\n\n    console.log('Audio file stored as reference:', file.name)\n    return stored\n  }\n\n  async retrieveAudioFile(storedFile: StoredAudioFile): Promise<AudioFile | null> {\n    try {\n      switch (storedFile.storageType) {\n        case 'base64':\n          return this.retrieveFromBase64(storedFile)\n\n        case 'indexeddb':\n          return await this.retrieveFromIndexedDB(storedFile)\n\n        case 'reference':\n          return await this.retrieveFromReference(storedFile)\n\n        default:\n          throw new Error(`Unknown storage type: ${storedFile.storageType}`)\n      }\n    } catch (error) {\n      console.error('Error retrieving audio file:', error)\n      return null\n    }\n  }\n\n  private retrieveFromBase64(storedFile: StoredAudioFile): AudioFile {\n    if (!storedFile.data) {\n      throw new Error('No base64 data found')\n    }\n\n    // Convert base64 back to blob\n    const byteCharacters = atob(storedFile.data.split(',')[1])\n    const byteNumbers = new Array(byteCharacters.length)\n\n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i)\n    }\n\n    const byteArray = new Uint8Array(byteNumbers)\n    const blob = new Blob([byteArray], { type: storedFile.type })\n    const file = new File([blob], storedFile.name, {\n      type: storedFile.type,\n      lastModified: storedFile.lastModified,\n    })\n\n    return {\n      name: storedFile.name,\n      file: file,\n      url: URL.createObjectURL(file),\n    }\n  }\n\n  private async retrieveFromIndexedDB(storedFile: StoredAudioFile): Promise<AudioFile> {\n    if (!this.db || !storedFile.indexed_id) {\n      throw new Error('IndexedDB not available or no ID provided')\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readonly')\n      const store = transaction.objectStore(this.storeName)\n      const request = store.get(storedFile.indexed_id!)\n\n      request.onsuccess = () => {\n        const result = request.result\n        if (result && result.file) {\n          resolve({\n            name: result.name,\n            file: result.file,\n            url: URL.createObjectURL(result.file),\n          })\n        } else {\n          reject(new Error('Audio file not found in IndexedDB'))\n        }\n      }\n\n      request.onerror = () => reject(request.error)\n    })\n  }\n\n  private async retrieveFromReference(storedFile: StoredAudioFile): Promise<AudioFile> {\n    // For reference storage, we need to prompt the user to re-select the file\n    return new Promise((resolve, reject) => {\n      const dialog = this.createFileSelectionDialog(storedFile)\n      document.body.appendChild(dialog)\n\n      const fileInput = dialog.querySelector('input[type=\"file\"]') as HTMLInputElement\n      const selectBtn = dialog.querySelector('.btn-primary') as HTMLButtonElement\n      const cancelBtn = dialog.querySelector('.btn-secondary') as HTMLButtonElement\n\n      selectBtn.addEventListener('click', () => {\n        const selectedFile = fileInput.files?.[0]\n        if (selectedFile) {\n          // Verify it's likely the same file\n          if (selectedFile.name === storedFile.name && Math.abs(selectedFile.size - storedFile.size) < 1024) {\n            resolve({\n              name: selectedFile.name,\n              file: selectedFile,\n              url: URL.createObjectURL(selectedFile),\n            })\n          } else {\n            const proceed = confirm(\n              `The selected file (${selectedFile.name}, ${(selectedFile.size / 1024 / 1024).toFixed(2)}MB) ` +\n              `doesn't exactly match the original (${storedFile.name}, ${(storedFile.size / 1024 / 1024).toFixed(2)}MB). ` +\n              'Use it anyway?'\n            )\n            if (proceed) {\n              resolve({\n                name: selectedFile.name,\n                file: selectedFile,\n                url: URL.createObjectURL(selectedFile),\n              })\n            } else {\n              reject(new Error('File selection cancelled'))\n            }\n          }\n        } else {\n          reject(new Error('No file selected'))\n        }\n        document.body.removeChild(dialog)\n      })\n\n      cancelBtn.addEventListener('click', () => {\n        document.body.removeChild(dialog)\n        reject(new Error('File selection cancelled'))\n      })\n    })\n  }\n\n  private createFileSelectionDialog(storedFile: StoredAudioFile): HTMLElement {\n    const dialog = document.createElement('div')\n    dialog.className = 'modal show'\n    dialog.style.display = 'block'\n    dialog.style.backgroundColor = 'rgba(0,0,0,0.5)'\n\n    dialog.innerHTML = `\n      <div class=\"modal-dialog\">\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <h5 class=\"modal-title\">ðŸŽµ Locate Audio File</h5>\n          </div>\n          <div class=\"modal-body\">\n            <p><strong>Missing audio file:</strong></p>\n            <div class=\"alert alert-info\">\n              <strong>File:</strong> ${storedFile.name}<br>\n              <strong>Size:</strong> ${(storedFile.size / 1024 / 1024).toFixed(2)} MB<br>\n              <strong>Type:</strong> ${storedFile.type}\n            </div>\n            <p>Please locate and select the original audio file to continue:</p>\n            <input type=\"file\" class=\"form-control\" accept=\"audio/*\">\n          </div>\n          <div class=\"modal-footer\">\n            <button type=\"button\" class=\"btn btn-secondary\">Cancel</button>\n            <button type=\"button\" class=\"btn btn-primary\">Use Selected File</button>\n          </div>\n        </div>\n      </div>\n    `\n\n    return dialog\n  }\n\n  async deleteAudioFile(storedFile: StoredAudioFile): Promise<void> {\n    try {\n      // Remove from localStorage\n      const keys = Object.keys(localStorage)\n\n      switch (storedFile.storageType) {\n        case 'base64':\n          for (const key of keys) {\n            if (key.startsWith('audio_') && localStorage.getItem(key)?.includes(storedFile.name)) {\n              localStorage.removeItem(key)\n              break\n            }\n          }\n          break\n\n        case 'indexeddb':\n          if (this.db && storedFile.indexed_id) {\n            const transaction = this.db.transaction([this.storeName], 'readwrite')\n            const store = transaction.objectStore(this.storeName)\n            store.delete(storedFile.indexed_id)\n          }\n          break\n\n        case 'reference':\n          // Nothing to delete for references\n          break\n      }\n      console.log('Audio file deleted:', storedFile.name)\n    } catch (error) {\n      console.error('Error deleting audio file:', error)\n    }\n  }\n\n  getStorageInfo(): { method: string; sizeMB: number; count: number; quotaUsedMB: number; quotaLimitMB: number } {\n    let sizeMB = 0\n    let count = 0\n\n    // Count base64 files in localStorage\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('audio_')) {\n        try {\n          const data = JSON.parse(localStorage.getItem(key) || '{}')\n          if (data.size) {\n            sizeMB += data.size / 1024 / 1024\n            count++\n          }\n        } catch (e) {\n          // Ignore invalid entries\n        }\n      }\n    })\n\n    const quotaUsedMB = this.getLocalStorageUsage() / 1024 / 1024\n    const quotaLimitMB = this.db ? 1000 : 10 // IndexedDB ~1GB limit, localStorage ~10MB\n\n    return {\n      method: this.db ? 'indexeddb' : this.options.preferredMethod,\n      sizeMB: Math.round(sizeMB * 100) / 100,\n      count,\n      quotaUsedMB: Math.round(quotaUsedMB * 100) / 100,\n      quotaLimitMB,\n    }\n  }\n\n  async clearOldAudioFiles(): Promise<number> {\n    let cleared = 0\n    const keysToRemove: string[] = []\n\n    // Find audio files in localStorage\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('audio_')) {\n        keysToRemove.push(key)\n      }\n    })\n\n    // Remove them\n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key)\n      cleared++\n    })\n\n    console.log(`Cleared ${cleared} audio files from localStorage`)\n    return cleared\n  }\n\n  setStorageOptions(options: Partial<AudioStorageOptions>): void {\n    this.options = {\n      ...this.options, ...options\n    }\n    console.log('Audio storage options updated:', this.options)\n  }\n\n  // Diagnostic method to test IndexedDB functionality\n  async testIndexedDBConnection(): Promise<{ available: boolean; error?: string; canStore: boolean }> {\n    const result = {\n      available: false, canStore: false, error: undefined as string | undefined\n    }\n\n    try {\n      // Check if IndexedDB exists\n      if (!window.indexedDB) {\n        result.error = 'IndexedDB not supported by browser'\n        return result\n      }\n\n      result.available = true\n\n      // Test if we can actually open our database\n      if (!this.db) {\n        await this.initIndexedDB()\n      }\n\n      if (this.db) {\n        result.canStore = true\n        console.log('âœ… IndexedDB connection test successful')\n      } else {\n        result.error = 'Could not initialize IndexedDB database'\n      }\n    } catch (error) {\n      result.error = error instanceof Error ? error.message : 'Unknown IndexedDB error'\n    }\n\n    return result\n  }\n}\n\n// Export singleton instance\nexport const audioStorageService = new AudioStorageService()\n"],"names":["exports","dbName","dbVersion","storeName","db","options","maxSizeForBase64","preferredMethod","constructor","this","initIndexedDB","Promise","resolve","window","indexedDB","console","warn","request","open","onerror","onsuccess","result","log","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","storeAudioFile","file","projectId","audioId","name","lastModified","fileSizeMB","size","toFixed","storeInIndexedDB","indexedError","storeAsBase64","base64Error","Error","message","alert","storeAsReference","error","reject","reader","FileReader","onload","base64Data","stored","type","storageType","data","dataString","JSON","stringify","currentUsage","getLocalStorageUsage","length","localStorage","setItem","includes","readAsDataURL","total","key","Object","prototype","hasOwnProperty","call","transaction","store","objectStore","audioData","id","put","indexed_id","originalPath","retrieveAudioFile","storedFile","retrieveFromBase64","retrieveFromIndexedDB","retrieveFromReference","byteCharacters","atob","split","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","blob","Blob","File","url","URL","createObjectURL","get","dialog","createFileSelectionDialog","document","body","appendChild","fileInput","querySelector","selectBtn","cancelBtn","addEventListener","selectedFile","files","Math","abs","confirm","removeChild","createElement","className","style","display","backgroundColor","innerHTML","deleteAudioFile","keys","startsWith","getItem","removeItem","delete","getStorageInfo","sizeMB","count","forEach","parse","e","quotaUsedMB","quotaLimitMB","method","round","clearOldAudioFiles","cleared","keysToRemove","push","setStorageOptions","testIndexedDBConnection","available","canStore"],"mappings":"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"}