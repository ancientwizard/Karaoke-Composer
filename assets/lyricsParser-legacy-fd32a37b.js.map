{"version":3,"file":"lyricsParser-legacy-fd32a37b.js","sources":["../../src/utils/lyricsParser.ts","../../src/models/KaraokeTimingEngine.ts","../../src/models/TimingConstants.ts"],"sourcesContent":["// Utility functions for parsing lyrics with syllable markers\nimport type { LyricLine, WordTiming, SyllableTiming, LyricsMetadata } from '@/types/karaoke'\nimport { KaraokeTimingEngine } from '@/models/KaraokeTimingEngine'\nimport { TIMING, TimingUtils } from '@/models/TimingConstants'\n\n/**\n * Parse a line of text with syllable markers (/) into structured word/syllable data\n * Example: \"Hel/lo world a/maz/ing\" -> [{ word: \"Hello\", syllables: [\"Hel\", \"lo\"] }, ...]\n */\nexport function parseLyricsLine(text: string, lineNumber: number, lineId: string): LyricLine {\n  const words: WordTiming[] = []\n\n  // Split by spaces to get words\n  const wordTexts = text.split(/\\s+/).filter(word => word.length > 0)\n\n  wordTexts.forEach((wordText) => {\n    // Split word by \"/\" to get syllables\n    const syllableTexts = wordText.split('/').filter(syl => syl.length > 0)\n\n    const syllables: SyllableTiming[] = syllableTexts.map((syllableText) => ({\n      syllable: syllableText,\n      // startTime, endTime, duration will be added during timing\n    }))\n\n    // Reconstruct the full word without syllable markers\n    const fullWord = syllableTexts.join('')\n\n    words.push({\n      word: fullWord,\n      syllables: syllables,\n      // startTime, endTime, duration will be added during timing\n    })\n  })\n\n  return {\n    id: lineId,\n    lineNumber: lineNumber,\n    text: text, // Keep original text with markers\n    words: words,\n    // startTime, endTime, duration will be added during timing\n  }\n}\n\n/**\n * Convert structured lyrics back to text with syllable markers\n */\nexport function lyricLineToText(lyricLine: LyricLine): string {\n  return lyricLine.words\n    .map(word => {\n      if (word.syllables.length <= 1) {\n        return word.word\n      } else {\n        return word.syllables.map(syl => syl.syllable).join('/')\n      }\n    })\n    .join(' ')\n}\n\n/**\n * Parse multiple lines of lyrics text\n */\nexport function parseLyricsText(lyricsText: string): LyricLine[] {\n  if (!lyricsText || typeof lyricsText !== 'string') {\n    return []\n  }\n\n  const lines = lyricsText.split('\\n').filter(line => line.trim().length > 0)\n\n  return lines.map((line, index) => parseLyricsLine(line.trim(), index + 1, `line-${Date.now()}-${index}`))\n}\n\n/**\n * Find the current word/syllable based on playback time\n * Uses our improved KaraokeTimingEngine for accurate detection\n */\nexport function getCurrentPosition(\n  lyrics: LyricLine[],\n  currentTime: number\n): {\n  lineIndex: number\n  wordIndex: number\n  syllableIndex: number\n  line?: LyricLine\n  word?: WordTiming\n  syllable?: SyllableTiming\n} {\n  // Use our improved timing engine for position detection\n  const engine = new KaraokeTimingEngine({ silent: true })\n  engine.loadLyrics(lyrics)\n\n  const position = engine.getCurrentPosition(currentTime)\n\n  // Return compatible format with additional line/word/syllable objects\n  const result = {\n    lineIndex: position.lineIndex,\n    wordIndex: position.wordIndex,\n    syllableIndex: position.syllableIndex,\n    line: undefined as LyricLine | undefined,\n    word: undefined as WordTiming | undefined,\n    syllable: undefined as SyllableTiming | undefined\n  }\n\n  // Add the actual objects if position is valid and active\n  if (position.isActive && position.lineIndex < lyrics.length) {\n    const line = lyrics[position.lineIndex]\n    result.line = line\n\n    if (position.wordIndex < line.words.length) {\n      const word = line.words[position.wordIndex]\n      result.word = word\n\n      if (position.syllableIndex < word.syllables.length) {\n        result.syllable = word.syllables[position.syllableIndex]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Assign timing to a word (spacebar functionality)\n */\nexport function assignWordTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  startTime: number,\n  estimatedWordDuration: number = 500 // Default 500ms per word\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex]) {\n    const word = line.words[wordIndex]\n    word.startTime = startTime\n    word.endTime = startTime + estimatedWordDuration\n    word.duration = estimatedWordDuration\n\n    // DON'T assign syllable timing yet - defer until we know actual word duration\n    // This will be calculated later when the next word gets its timing\n    // For now, just clear any existing syllable timing\n    word.syllables.forEach((syllable) => {\n      syllable.startTime = undefined\n      syllable.endTime = undefined\n      syllable.duration = undefined\n    })\n\n    // Now recalculate syllable timing for the PREVIOUS word if it exists\n    // Use CONSERVATIVE duration to prevent syllables from spilling into gaps\n    if (wordIndex > 0) {\n      const prevWord = line.words[wordIndex - 1]\n      if (prevWord.startTime !== undefined) {\n        const fullGap = startTime - prevWord.startTime\n        // Use centralized conservative gap usage rules\n        const conservativeDuration = TimingUtils.getConservativeDuration(fullGap, false)\n        distributeSyllableTiming(prevWord, prevWord.startTime, conservativeDuration)\n      }\n    } else if (lineIndex > 0) {\n      // Check previous line's last word\n      const prevLine = updatedLyrics[lineIndex - 1]\n      if (prevLine && prevLine.words.length > 0) {\n        const lastWordOfPrevLine = prevLine.words[prevLine.words.length - 1]\n        if (lastWordOfPrevLine.startTime !== undefined) {\n          const fullGap = startTime - lastWordOfPrevLine.startTime\n          // Use centralized line-ending gap usage rules\n          const conservativeDuration = TimingUtils.getConservativeDuration(fullGap, true)\n          distributeSyllableTiming(lastWordOfPrevLine, lastWordOfPrevLine.startTime, conservativeDuration)\n        }\n      }\n    }\n\n    // Update line timing\n    updateLineTiming(line)\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Distribute syllable timing within a word based on actual duration\n */\nfunction distributeSyllableTiming(word: WordTiming, wordStartTime: number, actualDuration: number) {\n  if (word.syllables.length <= 1) {\n    // Single syllable gets full word timing\n    if (word.syllables[0]) {\n      word.syllables[0].startTime = wordStartTime\n      word.syllables[0].endTime = wordStartTime + actualDuration\n      word.syllables[0].duration = actualDuration\n    }\n  } else {\n    // Multiple syllables - use centralized timing rules for smart distribution\n    const syllableCount = word.syllables.length\n    const totalMinDuration = TIMING.syllable.minDuration * syllableCount\n\n    if (actualDuration < totalMinDuration) {\n      // Duration too short for safe syllable distribution - extend the word\n      console.warn(`⚠️ Word \"${word.word}\" duration (${actualDuration}ms) too short for ${syllableCount} syllables. Extending to ${totalMinDuration}ms`)\n      actualDuration = totalMinDuration\n    }\n\n    // Use centralized syllable weighting system\n    const weights = TimingUtils.calculateSyllableWeights(syllableCount)\n\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n    const availableDuration = actualDuration - totalMinDuration // Extra duration to distribute\n\n    let currentTime = wordStartTime\n    word.syllables.forEach((syllable, index) => {\n      const baseMinDuration = TIMING.syllable.minDuration\n      const extraDuration = (weights[index] / totalWeight) * availableDuration\n      const syllableDuration = TimingUtils.constrainDuration(baseMinDuration + extraDuration, false)\n\n      syllable.startTime = currentTime\n      syllable.endTime = currentTime + syllableDuration\n      syllable.duration = syllableDuration\n      currentTime = syllable.endTime\n    })\n  }\n\n  // Update word timing to match actual duration\n  word.endTime = wordStartTime + actualDuration\n  word.duration = actualDuration\n}\n\n/**\n * Finalize syllable timing for words that don't have a next word to define their end time\n * This should be called for the last word in a line/song or when timing is complete\n */\nexport function finalizePendingSyllableTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  estimatedDuration: number = 500\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex]) {\n    const word = line.words[wordIndex]\n    if (word.startTime !== undefined && word.syllables.some(s => s.startTime === undefined)) {\n      // This word has no syllable timing yet, finalize it with estimated duration\n      distributeSyllableTiming(word, word.startTime, estimatedDuration)\n    }\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Assign timing to a specific syllable (manual adjustment)\n */\nexport function assignSyllableTiming(\n  lyrics: LyricLine[],\n  lineIndex: number,\n  wordIndex: number,\n  syllableIndex: number,\n  startTime: number,\n  duration: number\n): LyricLine[] {\n  const updatedLyrics = [...lyrics]\n  const line = updatedLyrics[lineIndex]\n\n  if (line && line.words[wordIndex] && line.words[wordIndex].syllables[syllableIndex]) {\n    const syllable = line.words[wordIndex].syllables[syllableIndex]\n    syllable.startTime = startTime\n    syllable.endTime = startTime + duration\n    syllable.duration = duration\n\n    // Update word timing based on syllables\n    updateWordTiming(line.words[wordIndex])\n\n    // Update line timing\n    updateLineTiming(line)\n  }\n\n  return updatedLyrics\n}\n\n/**\n * Update word timing based on syllable timings\n */\nfunction updateWordTiming(word: WordTiming): void {\n  const timedSyllables = word.syllables.filter(syl => syl.startTime !== undefined && syl.endTime !== undefined)\n\n  if (timedSyllables.length > 0) {\n    const startTimes = timedSyllables.map(syl => syl.startTime!).filter(t => t !== undefined)\n    const endTimes = timedSyllables.map(syl => syl.endTime!).filter(t => t !== undefined)\n\n    word.startTime = Math.min(...startTimes)\n    word.endTime = Math.max(...endTimes)\n    word.duration = word.endTime - word.startTime\n  }\n}\n\n/**\n * Update line timing based on word timings\n */\nfunction updateLineTiming(line: LyricLine): void {\n  const timedWords = line.words.filter(word => word.startTime !== undefined && word.endTime !== undefined)\n\n  if (timedWords.length > 0) {\n    const startTimes = timedWords.map(word => word.startTime!).filter(t => t !== undefined)\n    const endTimes = timedWords.map(word => word.endTime!).filter(t => t !== undefined)\n\n    line.startTime = Math.min(...startTimes)\n    line.endTime = Math.max(...endTimes)\n    line.duration = line.endTime - line.startTime\n  }\n}\n\n/**\n * Calculate completion statistics\n */\nexport function getTimingStats(lyrics: LyricLine[]): {\n  totalLines: number\n  timedLines: number\n  totalWords: number\n  timedWords: number\n  totalSyllables: number\n  timedSyllables: number\n  completionPercent: number\n} {\n  let totalWords = 0\n  let timedWords = 0\n  let totalSyllables = 0\n  let timedSyllables = 0\n  let timedLines = 0\n\n  lyrics.forEach(line => {\n    if (line.startTime !== undefined && line.endTime !== undefined) {\n      timedLines++\n    }\n\n    line.words.forEach(word => {\n      totalWords++\n      if (word.startTime !== undefined && word.endTime !== undefined) {\n        timedWords++\n      }\n\n      word.syllables.forEach(syllable => {\n        totalSyllables++\n        if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n          timedSyllables++\n        }\n      })\n    })\n  })\n\n  const completionPercent = totalSyllables > 0 ? Math.round((timedSyllables / totalSyllables) * 100) : 0\n\n  return {\n    totalLines: lyrics.length,\n    timedLines,\n    totalWords,\n    timedWords,\n    totalSyllables,\n    timedSyllables,\n    completionPercent,\n  }\n}\n\n/**\n * Check if a line contains metadata ([@TITLE:], [@AUTHOR:], [@CAPTION:])\n */\nexport function isMetadataLine(text: string): boolean {\n  return /^\\[@(TITLE|AUTHOR|CAPTION):.+\\]/.test(text.trim())\n}\n\n/**\n * Parse metadata from a line\n */\nexport function parseMetadataLine(text: string): {\n  type: 'title' | 'author' | 'caption'\n  value: string\n} | null {\n  const trimmed = text.trim()\n\n  const titleMatch = trimmed.match(/^\\[@TITLE:(.+)\\]/)\n  if (titleMatch) {\n    return {\n      type: 'title',\n      value: titleMatch[1].trim()\n    }\n  }\n\n  const authorMatch = trimmed.match(/^\\[@AUTHOR:(.+)\\]/)\n  if (authorMatch) {\n    return {\n      type: 'author',\n      value: authorMatch[1].trim()\n    }\n  }\n\n  const captionMatch = trimmed.match(/^\\[@CAPTION:(.+)\\]/)\n  if (captionMatch) {\n    return {\n      type: 'caption',\n      value: captionMatch[1].trim()\n    }\n  }\n\n  return null\n}\n\n/**\n * Parse lyrics text with metadata support\n */\nexport function parseLyricsWithMetadata(lyricsText: string): {\n  lyrics: LyricLine[]\n  metadata: LyricsMetadata\n} {\n  if (!lyricsText || typeof lyricsText !== 'string') {\n    return {\n      lyrics: [],\n      metadata: {}\n    }\n  }\n\n  const lines = lyricsText.split('\\n').map(line => line.trim()).filter(line => line.length > 0)\n  const lyrics: LyricLine[] = []\n  const metadata: LyricsMetadata = {}\n\n  let lyricsLineNumber = 1\n  let pendingCaption: string | null = null  // Store caption to attach to next lyrics line\n\n  // Process each line\n  lines.forEach((line, originalIndex) => {\n    const metadataInfo = parseMetadataLine(line)\n\n    if (metadataInfo) {\n      // Handle metadata lines\n      const metadataLine: LyricLine = {\n        id: `metadata-${originalIndex}`,\n        lineNumber: lyricsLineNumber,\n        text: line,\n        words: [],\n        type: metadataInfo.type,\n        metadata: { [metadataInfo.type]: metadataInfo.value }\n      }\n\n      // Store in metadata object for easy access\n      if (metadataInfo.type === 'title') {\n        metadata.title = metadataInfo.value\n      } else if (metadataInfo.type === 'author') {\n        metadata.author = metadataInfo.value\n      } else if (metadataInfo.type === 'caption') {\n        if (!metadata.captions) metadata.captions = []\n        metadata.captions.push(metadataInfo.value)\n        // Store caption to also attach to next lyrics line\n        pendingCaption = metadataInfo.value\n      }\n\n      lyrics.push(metadataLine)\n      lyricsLineNumber++\n    } else {\n      // Handle regular lyrics lines\n      const lyricLine = parseLyricsLine(line, lyricsLineNumber, `line-${lyricsLineNumber}`)\n      lyricLine.type = 'lyrics'\n\n      // Attach pending caption if exists (for export purposes)\n      if (pendingCaption) {\n        if (!lyricLine.metadata) {\n          lyricLine.metadata = {}\n        }\n        lyricLine.metadata.caption = pendingCaption\n        pendingCaption = null\n      }\n\n      lyrics.push(lyricLine)\n      lyricsLineNumber++\n    }\n  })  // Move title to first position if it exists but isn't first\n  const titleLineIndex = lyrics.findIndex(line => line.type === 'title')\n  if (titleLineIndex > 0) {\n    const titleLine = lyrics.splice(titleLineIndex, 1)[0]\n    lyrics.unshift(titleLine)\n    // Renumber all lines\n    lyrics.forEach((line, index) => {\n      line.lineNumber = index + 1\n    })\n  }\n\n  return {\n    lyrics,\n    metadata\n  }\n}\n\n/**\n * Clears timing data from a line and all subsequent lines to prevent inconsistencies\n * This ensures that timing data remains sequential and doesn't have gaps\n */\nexport function clearTimingFromLine(lyrics: LyricLine[], fromLineIndex: number): LyricLine[] {\n  const result = [...lyrics]\n\n  // Clear timing from the specified line and all subsequent lines\n  for (let lineIndex = fromLineIndex; lineIndex < result.length; lineIndex++) {\n    const line = result[lineIndex]\n\n    // Skip metadata lines - they don't have timing\n    if (line.type && line.type !== 'lyrics') {\n      continue\n    }\n\n    // Clear line-level timing\n    line.startTime = undefined\n    line.endTime = undefined\n    line.duration = undefined\n\n    // Clear word-level timing for all words in this line\n    if (line.words) {\n      line.words.forEach(word => {\n        word.startTime = undefined\n        word.endTime = undefined\n        word.duration = undefined\n\n        // Clear syllable-level timing for all syllables in this word\n        if (word.syllables) {\n          word.syllables.forEach(syllable => {\n            syllable.startTime = undefined\n            syllable.endTime = undefined\n            syllable.duration = undefined\n          })\n        }\n      })\n    }\n  }\n\n  return result\n}\n","/**\n * Pure TypeScript Karaoke Timing Engine\n * Handles all timing logic independent of Vue/UI\n * Can be tested with synthetic time progression\n */\n\nimport type { LyricLine, WordTiming } from '@/types/karaoke'\n\nexport interface TimingEvent {\n  type: 'word_start' | 'word_end' | 'syllable_start' | 'syllable_end' | 'line_start' | 'line_end' | 'phrase_gap'\n  timestamp: number\n  lineIndex: number\n  wordIndex?: number\n  syllableIndex?: number\n  text?: string\n  expectedDuration?: number\n}\n\nexport interface TimingConfiguration {\n  // Syllable timing weights\n  syllableWeights: {\n    first: number\n    middle: number\n    last: number\n  }\n\n  // Gap detection settings\n  gaps: {\n    shortPause: number // ms - comma, short breath\n    mediumPause: number // ms - period, end of phrase\n    longPause: number // ms - line break, new verse\n  }\n\n  // Minimum durations\n  minimums: {\n    syllableDuration: number // ms\n    wordDuration: number // ms\n    lineDuration: number // ms\n  }\n}\n\nexport class KaraokeTimingEngine {\n  private lyrics: LyricLine[] = []\n  private eventLog: TimingEvent[] = []\n  private config: TimingConfiguration\n  private silent: boolean\n\n  constructor(config?: Partial<TimingConfiguration> & { silent?: boolean }) {\n    this.silent = config?.silent || false\n\n    this.config = {\n      syllableWeights: {\n        first: 0.7,\n        middle: 0.8,\n        last: 2.0\n      },\n      gaps: {\n        shortPause: 100,   // comma, quick breath\n        mediumPause: 300,  // period, phrase end\n        longPause: 800     // line break, verse change\n      },\n      minimums: {\n        syllableDuration: 150,\n        wordDuration: 200,\n        lineDuration: 1000\n      },\n      ...config\n    }\n\n    this.log('ENGINE_INIT', 0, -1, undefined, undefined, 'Karaoke Timing Engine initialized')\n  }\n\n  /**\n   * Load lyrics into the engine\n   */\n  loadLyrics(lyrics: LyricLine[]): void {\n    this.lyrics = [...lyrics]\n    this.eventLog = []\n    this.log('LYRICS_LOADED', 0, -1, undefined, undefined, `Loaded ${lyrics.length} lines`)\n  }\n\n  /**\n   * Apply timing to a word at the current timestamp\n   */\n  assignWordTiming(lineIndex: number, wordIndex: number, timestamp: number): TimingEvent[] {\n    const events: TimingEvent[] = []\n\n    if (!this.isValidPosition(lineIndex, wordIndex)) {\n      this.log('ERROR_INVALID_POSITION', timestamp, lineIndex, wordIndex)\n      return events\n    }\n\n    const word = this.lyrics[lineIndex].words[wordIndex]\n    const previousWord = this.getPreviousWord(lineIndex, wordIndex)\n\n    // Finalize previous word if it exists and has timing\n    if (previousWord && previousWord.word.startTime !== undefined) {\n      const actualDuration = timestamp - previousWord.word.startTime\n      this.finalizeWordTiming(previousWord, actualDuration, timestamp)\n\n      events.push({\n        type: 'word_end',\n        timestamp,\n        lineIndex: previousWord.lineIndex,\n        wordIndex: previousWord.wordIndex,\n        text: previousWord.word.word,\n        expectedDuration: actualDuration\n      })\n\n      // Detect gap between words\n      const gap = this.detectGap(word.word, actualDuration)\n      if (gap > this.config.gaps.shortPause) {\n        events.push({\n          type: 'phrase_gap',\n          timestamp,\n          lineIndex,\n          wordIndex,\n          expectedDuration: gap\n        })\n      }\n    }\n\n    // Start new word\n    word.startTime = timestamp\n    word.endTime = undefined // Will be set when next word starts\n\n    events.push({\n      type: 'word_start',\n      timestamp,\n      lineIndex,\n      wordIndex,\n      text: word.word\n    })\n\n    this.log('WORD_ASSIGNED', timestamp, lineIndex, wordIndex, undefined, word.word)\n    return events\n  }\n\n  /**\n   * Finalize all remaining words (end of song)\n   */\n  finalizeAllTiming(endTimestamp: number): TimingEvent[] {\n    const events: TimingEvent[] = []\n\n    // Find the last word with timing\n    const lastWord = this.findLastTimedWord()\n    if (lastWord && lastWord.word.startTime !== undefined) {\n      const estimatedDuration = this.estimateWordDuration(lastWord.word)\n      this.finalizeWordTiming(lastWord, estimatedDuration, endTimestamp)\n\n      events.push({\n        type: 'word_end',\n        timestamp: endTimestamp,\n        lineIndex: lastWord.lineIndex,\n        wordIndex: lastWord.wordIndex,\n        text: lastWord.word.word,\n        expectedDuration: estimatedDuration\n      })\n    }\n\n    this.log('TIMING_FINALIZED', endTimestamp, -1)\n    return events\n  }\n\n  /**\n   * Get current position based on timestamp\n   */\n  getCurrentPosition(timestamp: number): {\n    lineIndex: number\n    wordIndex: number\n    syllableIndex: number\n    isActive: boolean\n  } {\n    for (let lineIndex = 0; lineIndex < this.lyrics.length; lineIndex++) {\n      const line = this.lyrics[lineIndex]\n\n      for (let wordIndex = 0; wordIndex < line.words.length; wordIndex++) {\n        const word = line.words[wordIndex]\n\n        if (word.startTime !== undefined) {\n          if (word.endTime !== undefined) {\n            // Finalized word - use exact timing\n            // Use < for endTime to ensure proper word transitions at boundaries\n            if (timestamp >= word.startTime && timestamp < word.endTime) {\n              const syllableIndex = this.findCurrentSyllable(word, timestamp)\n              return {\n                lineIndex, wordIndex, syllableIndex, isActive: true\n              }\n            }\n          } else {\n            // Current active word (not finalized yet)\n            // Check if this is the current word by seeing if timestamp is after its start\n            // and there's no next word with timing yet\n            if (timestamp >= word.startTime) {\n              // Check if there's a next word that started\n              const nextWord = this.getNextWord(lineIndex, wordIndex)\n              if (!nextWord || nextWord.word.startTime === undefined || timestamp < nextWord.word.startTime) {\n                // This is the current active word\n                const syllableIndex = this.findCurrentSyllable(word, timestamp)\n                return {\n                  lineIndex, wordIndex, syllableIndex, isActive: true\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      lineIndex: 0, wordIndex: 0, syllableIndex: 0, isActive: false\n    }\n  }\n\n  /**\n   * Get all events that occurred during timing\n   */\n  getEventLog(): TimingEvent[] {\n    return [...this.eventLog]\n  }\n\n  /**\n   * Get timing statistics\n   */\n  getStats(): {\n    totalWords: number\n    timedWords: number\n    totalSyllables: number\n    timedSyllables: number\n    averageWordDuration: number\n    completionPercent: number\n    eventCount: number\n  } {\n    let totalWords = 0\n    let timedWords = 0\n    let totalSyllables = 0\n    let timedSyllables = 0\n    let totalDuration = 0\n\n    this.lyrics.forEach(line => {\n      line.words.forEach(word => {\n        totalWords++\n        if (word.startTime !== undefined) {\n          timedWords++\n          if (word.endTime !== undefined) {\n            totalDuration += (word.endTime - word.startTime)\n          }\n        }\n\n        word.syllables.forEach(syllable => {\n          totalSyllables++\n          if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n            timedSyllables++\n          }\n        })\n      })\n    })\n\n    return {\n      totalWords,\n      timedWords,\n      totalSyllables,\n      timedSyllables,\n      averageWordDuration: timedWords > 0 ? totalDuration / timedWords : 0,\n      completionPercent: totalWords > 0 ? (timedWords / totalWords) * 100 : 0,\n      eventCount: this.eventLog.length\n    }\n  }\n\n  // Private helper methods\n\n  private isValidPosition(lineIndex: number, wordIndex: number): boolean {\n    return lineIndex >= 0 &&\n      lineIndex < this.lyrics.length &&\n      wordIndex >= 0 &&\n      wordIndex < this.lyrics[lineIndex].words.length\n  }\n\n  private getPreviousWord(lineIndex: number, wordIndex: number): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    if (wordIndex > 0) {\n      return {\n        lineIndex,\n        wordIndex: wordIndex - 1,\n        word: this.lyrics[lineIndex].words[wordIndex - 1]\n      }\n    } else if (lineIndex > 0) {\n      const prevLine = this.lyrics[lineIndex - 1]\n      if (prevLine.words.length > 0) {\n        return {\n          lineIndex: lineIndex - 1,\n          wordIndex: prevLine.words.length - 1,\n          word: prevLine.words[prevLine.words.length - 1]\n        }\n      }\n    }\n    return null\n  }\n\n  private getNextWord(lineIndex: number, wordIndex: number): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    const currentLine = this.lyrics[lineIndex]\n    if (wordIndex < currentLine.words.length - 1) {\n      return {\n        lineIndex,\n        wordIndex: wordIndex + 1,\n        word: currentLine.words[wordIndex + 1]\n      }\n    } else if (lineIndex < this.lyrics.length - 1) {\n      const nextLine = this.lyrics[lineIndex + 1]\n      if (nextLine.words.length > 0) {\n        return {\n          lineIndex: lineIndex + 1,\n          wordIndex: 0,\n          word: nextLine.words[0]\n        }\n      }\n    }\n    return null\n  }\n\n  private finalizeWordTiming(\n    wordRef: { lineIndex: number, wordIndex: number, word: WordTiming },\n    actualDuration: number,\n    endTimestamp: number\n  ): void {\n    const { word } = wordRef\n\n    word.endTime = endTimestamp\n    word.duration = actualDuration\n\n    // Distribute syllable timing\n    this.distributeSyllableTiming(word, actualDuration)\n\n    this.log('WORD_FINALIZED', endTimestamp, wordRef.lineIndex, wordRef.wordIndex, undefined,\n      `${word.word} (${actualDuration}ms)`)\n  }\n\n  private distributeSyllableTiming(word: WordTiming, totalDuration: number): void {\n    if (word.syllables.length <= 1) {\n      // Single syllable gets full duration\n      if (word.syllables[0] && word.startTime !== undefined) {\n        word.syllables[0].startTime = word.startTime\n        word.syllables[0].endTime = word.startTime + totalDuration\n        word.syllables[0].duration = totalDuration\n      }\n      return\n    }\n\n    // Multiple syllables - use weighted distribution\n    const weights = word.syllables.map((_, index) => {\n      if (index === 0) return this.config.syllableWeights.first\n      if (index === word.syllables.length - 1) return this.config.syllableWeights.last\n      return this.config.syllableWeights.middle\n    })\n\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n    const syllableDurations = weights.map(weight => (weight / totalWeight) * totalDuration)\n\n    let currentTime = word.startTime!\n    word.syllables.forEach((syllable, index) => {\n      syllable.startTime = currentTime\n      syllable.endTime = currentTime + syllableDurations[index]\n      syllable.duration = syllableDurations[index]\n      currentTime = syllable.endTime\n\n      this.log('SYLLABLE_TIMED', syllable.startTime, -1, -1, index,\n        `${syllable.syllable} (${syllableDurations[index].toFixed(1)}ms)`)\n    })\n  }\n\n  private detectGap(text: string, previousDuration: number): number {\n    // Look at punctuation and word patterns to estimate gaps\n    if (text.includes(',') || text.includes(';')) {\n      return this.config.gaps.shortPause\n    } else if (text.includes('.') || text.includes('!') || text.includes('?')) {\n      return this.config.gaps.mediumPause\n    } else if (previousDuration > this.config.minimums.wordDuration * 2) {\n      // Previous word was held long - likely end of phrase\n      return this.config.gaps.mediumPause\n    }\n\n    return 0 // No gap detected\n  }\n\n  private findLastTimedWord(): {\n    lineIndex: number\n    wordIndex: number\n    word: WordTiming\n  } | null {\n    for (let lineIndex = this.lyrics.length - 1; lineIndex >= 0; lineIndex--) {\n      const line = this.lyrics[lineIndex]\n      for (let wordIndex = line.words.length - 1; wordIndex >= 0; wordIndex--) {\n        const word = line.words[wordIndex]\n        if (word.startTime !== undefined) {\n          return {\n            lineIndex, wordIndex, word\n          }\n        }\n      }\n    }\n    return null\n  }\n\n  private estimateWordDuration(word: WordTiming): number {\n    // Simple estimation based on syllable count and word length\n    const syllableCount = word.syllables.length\n    const baseTime = this.config.minimums.wordDuration\n    return baseTime + (syllableCount - 1) * this.config.minimums.syllableDuration\n  }\n\n  private findCurrentSyllable(word: WordTiming, timestamp: number): number {\n    // Check if syllables have timing (word has been finalized)\n    const hasTimedSyllables = word.syllables.some(s => s.startTime !== undefined && s.endTime !== undefined)\n\n    if (hasTimedSyllables) {\n      // Use actual syllable timing\n      for (let i = 0; i < word.syllables.length; i++) {\n        const syllable = word.syllables[i]\n        if (syllable.startTime !== undefined && syllable.endTime !== undefined) {\n          // Use < instead of <= for endTime to ensure proper syllable transitions\n          // At exactly the boundary time, we should move to the next syllable\n          if (timestamp >= syllable.startTime && timestamp < syllable.endTime) {\n            return i\n          }\n        }\n      }\n      // If we're past all syllables, return the last valid syllable index\n      return Math.max(0, word.syllables.length - 1)\n    } else {\n      // Word hasn't been finalized yet - estimate syllable timing on-the-fly\n      if (word.startTime === undefined || word.syllables.length <= 1) {\n        return 0\n      }\n\n      // Estimate which syllable should be active based on elapsed time\n      const elapsedTime = timestamp - word.startTime\n\n      // Use a simple progression: each syllable gets a minimum duration\n      // Find which syllable we should be in based on time thresholds\n      for (let i = 0; i < word.syllables.length; i++) {\n        const minTimeForThisSyllable = (i + 1) * this.config.minimums.syllableDuration\n\n        // If we haven't reached the time threshold for this syllable, return previous\n        if (elapsedTime < minTimeForThisSyllable) {\n          return Math.max(0, i)\n        }\n      }\n\n      // If we're well into the word, return the last syllable\n      return word.syllables.length - 1\n\n      // If we're well into the word, return the last syllable\n      return word.syllables.length - 1\n    }\n  }\n\n  private log(event: string, timestamp: number, lineIndex: number, wordIndex?: number, syllableIndex?: number, details?: string): void {\n    const logEntry = `[${timestamp.toFixed(0).padStart(6)}ms] ${event.padEnd(20)} L:${lineIndex.toString().padStart(2)} W:${(wordIndex ?? -1).toString().padStart(2)} S:${(syllableIndex ?? -1).toString().padStart(2)} ${details || ''}`\n\n    // Only log to console if not in silent mode (still store in eventLog for testing)\n    if (!this.silent) {\n      console.log(logEntry)\n    }\n\n    // Also store structured events for testing\n    this.eventLog.push({\n      type: event as any,\n      timestamp,\n      lineIndex,\n      wordIndex,\n      syllableIndex,\n      text: details\n    })\n  }\n}\n","/**\n * TIMING CONSTANTS - Central Configuration for All Timing Rules\n *\n * This is the single source of truth for all timing-related constants\n * used throughout the karaoke composer. All components and models should\n * consume these values instead of hardcoding their own.\n *\n * =====================================================\n * SYLLABLE DURATION RATIONALE - 50ms Minimum Analysis\n * =====================================================\n *\n * The 50ms minimum syllable duration has been validated across musical tempos:\n *\n * TEMPO ANALYSIS:\n * • Ballad (40-60 BPM):   50ms = 3-5% of beat,  allows 20-30 syllables/beat\n * • Mid-tempo (80-120 BPM): 50ms = 7-10% of beat, allows 10-15 syllables/beat\n * • Fast (144+ BPM):     50ms = 12% of beat,    allows 8+ syllables/beat\n *\n * HUMAN SPEECH CONTEXT:\n * • Normal speech syllables: 150-200ms (50ms is 25-33% of normal)\n * • Fast speech syllables: 80-120ms (50ms is 42-63% of fast speech)\n * • Rap/fast singing: 50-80ms (50ms matches lower bound of performance)\n * • Physical tongue/vocal limit: ~40ms (50ms provides safe margin)\n *\n * TECHNICAL CONSTRAINTS:\n * • Human audio perception: 20-30ms threshold (50ms is well above)\n * • Audio processing frames: ~23ms typical (50ms allows 2+ frames)\n * • Karaoke highlight flicker: 40-50ms threshold (50ms prevents flicker)\n *\n * CONCLUSION: 50ms provides excellent balance between:\n * - Musical flexibility (leaves 88-97% of beat time for expression)\n * - Technical safety (prevents UI flicker and audio artifacts)\n * - Performance realism (matches fast singing capabilities)\n * - Editor usability (prevents accidentally tiny syllables)\n */\n\nexport interface TimingRules {\n  // Word-level constraints\n  word: {\n    minDuration: number          // Minimum word duration (ms)\n    maxDuration: number          // Maximum reasonable word duration (ms)\n    collisionMargin: number      // Space between words to prevent overlap (ms)\n    defaultDuration: number      // Fallback duration when no timing available (ms)\n  }\n\n  // Syllable-level constraints\n  syllable: {\n    minDuration: number          // Minimum syllable duration for editor safety (ms)\n    defaultDuration: number      // Default syllable duration (ms)\n    lastSyllableWeight: number   // Multiplier for last syllable in weighted distribution\n    firstSyllableWeight: number  // Weight for first syllables\n    weightIncrement: number      // How much weight increases per syllable position\n  }\n\n  // Auto-timing behavior\n  autoTiming: {\n    normalWordSpacing: number    // Percentage of gap to use for normal words (0.0-1.0)\n    phraseBreakSpacing: number   // Percentage of gap to use for phrase breaks (0.0-1.0)\n    phraseBreakThreshold: number // Gap duration (seconds) that indicates phrase break\n    maxNormalDuration: number    // Max duration for normal spacing (ms)\n    maxPhraseBreakDuration: number // Max duration for phrase breaks (ms)\n    conservativeGapUsage: number // Percentage of gap for syllable distribution (0.0-1.0)\n    lineEndingGapUsage: number   // Percentage of gap for line-ending words (0.0-1.0)\n  }\n\n  // Musical timing intelligence\n  musical: {\n    restDuration: {\n      comma: number              // Rest after comma (ms)\n      period: number             // Rest after period/sentence (ms)\n      breath: number             // Natural breathing pause (ms)\n      phrase: number             // Phrase/verse break (ms)\n    }\n    notePatterns: {\n      eighth: number             // Eighth note duration base (ms)\n      quarter: number            // Quarter note duration base (ms)\n      half: number               // Half note duration base (ms)\n      whole: number              // Whole note duration base (ms)\n    }\n    conservativeMultiplier: number // When preserving timing, max percentage of gap to use\n  }\n\n  // Editor constraints\n  editor: {\n    pixelThreshold: number       // Minimum pixels for drag operations\n    snapThreshold: number        // Time threshold for snapping operations (ms)\n    viewportBuffer: number       // Buffer space at viewport edges (ms)\n    dragSensitivity: number      // Mouse movement sensitivity\n  }\n\n  // Validation and cleanup\n  validation: {\n    gapTolerance: number         // Max gap to auto-fix between syllables (ms)\n    overlapTolerance: number     // Max overlap to auto-fix between syllables (ms)\n    durationTolerance: number    // Tolerance for duration matching (ms)\n    timingPrecision: number      // Rounding precision for timing values (ms)\n  }\n\n  // Visual refresh and update rates\n  refresh: {\n    playbackUpdateHz: number     // Playback position update frequency (Hz)\n    fastModeMultiplier: number   // Multiplier for faster refresh mode\n    dragUpdateHz: number         // UI update frequency during drag operations (Hz)\n  }\n}\n\n/**\n * DEFAULT TIMING RULES - Carefully tuned values\n * These can be overridden in specific contexts, but provide sensible defaults\n */\nexport const DEFAULT_TIMING_RULES: TimingRules = {\n  word: {\n    minDuration: 100,            // 100ms minimum - shorter words feel too rushed\n    maxDuration: 2000,           // 2 seconds max - longer words feel unnatural\n    collisionMargin: 50,         // 50ms gap between words prevents overlap issues\n    defaultDuration: 500,        // 500ms default when no better info available\n  },\n\n  syllable: {\n    minDuration: 50,             // 50ms minimum - editor safety constraint\n    defaultDuration: 200,        // 200ms reasonable syllable duration\n    lastSyllableWeight: 2.0,     // Last syllable gets double time (musical)\n    firstSyllableWeight: 0.8,    // First syllables slightly shorter\n    weightIncrement: 0.1,        // Each syllable gets 10% more weight than previous\n  },\n\n  autoTiming: {\n    normalWordSpacing: 0.6,      // Use 60% of gap for normal words (was 82.5%)\n    phraseBreakSpacing: 0.25,    // Use 25% of gap for phrase breaks (was 50%)\n    phraseBreakThreshold: 3.0,   // 3+ second gaps indicate phrase breaks\n    maxNormalDuration: 600,      // Cap normal words at 600ms\n    maxPhraseBreakDuration: 800, // Cap phrase break words at 800ms\n    conservativeGapUsage: 0.7,   // Use 70% of gap for syllable distribution\n    lineEndingGapUsage: 0.5,     // Use 50% of gap for line-ending words\n  },\n\n  musical: {\n    restDuration: {\n      comma: 200,                // 200ms pause after comma\n      period: 800,               // 800ms pause after sentence\n      breath: 300,               // 300ms natural breath\n      phrase: 600,               // 600ms phrase break\n    },\n    notePatterns: {\n      eighth: 125,               // Eighth note ~120 BPM\n      quarter: 250,              // Quarter note ~120 BPM\n      half: 500,                 // Half note ~120 BPM\n      whole: 1000,               // Whole note ~120 BPM\n    },\n    conservativeMultiplier: 0.7, // Max 70% of gap when preserving timing\n  },\n\n  editor: {\n    pixelThreshold: 5,           // 5px minimum drag movement\n    snapThreshold: 10,           // 10ms snap threshold\n    viewportBuffer: 100,         // 100ms buffer at edges\n    dragSensitivity: 1.0,        // Normal drag sensitivity\n  },\n\n  validation: {\n    gapTolerance: 3,             // Auto-fix gaps up to 3ms\n    overlapTolerance: 3,         // Auto-fix overlaps up to 3ms\n    durationTolerance: 1,        // 1ms tolerance for duration matching\n    timingPrecision: 1,          // Round to nearest 1ms\n  },\n\n  refresh: {\n    playbackUpdateHz: 8,         // 8 Hz = 125ms intervals (2x faster than HTML5 default)\n    fastModeMultiplier: 1.5,     // 1.5x faster = 12 Hz for fast mode\n    dragUpdateHz: 60,            // 60 Hz for smooth drag operations (requestAnimationFrame)\n  }\n}\n\n/**\n * TIMING CONSTANTS - Global instance\n * Import and use this throughout the application\n */\nexport const TIMING = DEFAULT_TIMING_RULES\n\n/**\n * Utility functions for common timing calculations\n */\nexport class TimingUtils {\n  /**\n   * Calculate syllable weights for a given count\n   */\n  static calculateSyllableWeights(syllableCount: number): number[] {\n    return Array.from({ length: syllableCount }, (_, i) => {\n      if (i === syllableCount - 1) {\n        return TIMING.syllable.lastSyllableWeight\n      }\n      return TIMING.syllable.firstSyllableWeight + i * TIMING.syllable.weightIncrement\n    })\n  }\n\n  /**\n   * Determine if a gap indicates a phrase break\n   */\n  static isPhraseBreak(gapSeconds: number): boolean {\n    return gapSeconds > TIMING.autoTiming.phraseBreakThreshold\n  }\n\n  /**\n   * Calculate conservative duration from full gap\n   */\n  static getConservativeDuration(fullGap: number, isLineEnding: boolean = false): number {\n    const usage = isLineEnding ? TIMING.autoTiming.lineEndingGapUsage : TIMING.autoTiming.conservativeGapUsage\n    return fullGap * usage\n  }\n\n  /**\n   * Validate and constrain duration to reasonable bounds\n   */\n  static constrainDuration(duration: number, isWord: boolean = true): number {\n    const min = isWord ? TIMING.word.minDuration : TIMING.syllable.minDuration\n    const max = isWord ? TIMING.word.maxDuration : TIMING.word.maxDuration / 2 // Syllables max half word duration\n    return Math.max(min, Math.min(max, duration))\n  }\n\n  /**\n   * Round timing value to configured precision\n   */\n  static roundTiming(value: number): number {\n    return Math.round(value / TIMING.validation.timingPrecision) * TIMING.validation.timingPrecision\n  }\n\n  /**\n   * Get playback update interval in milliseconds\n   */\n  static getPlaybackUpdateInterval(fastMode: boolean = false): number {\n    const hz = fastMode\n      ? TIMING.refresh.playbackUpdateHz * TIMING.refresh.fastModeMultiplier\n      : TIMING.refresh.playbackUpdateHz\n    return 1000 / hz\n  }\n\n  /**\n   * Get drag update interval in milliseconds\n   */\n  static getDragUpdateInterval(): number {\n    return 1000 / TIMING.refresh.dragUpdateHz\n  }\n}\n\n/**\n * Export common timing constants for quick access\n */\nexport const {\n  word: WORD_TIMING,\n  syllable: SYLLABLE_TIMING,\n  autoTiming: AUTO_TIMING,\n  musical: MUSICAL_TIMING,\n  editor: EDITOR_TIMING,\n  validation: VALIDATION_TIMING\n} = TIMING\n"],"names":["lyrics","fromLineIndex","result","lineIndex","length","line","type","startTime","endTime","duration","words","forEach","word","syllables","syllable","totalWords","timedWords","totalSyllables","timedSyllables","timedLines","completionPercent","Math","round","totalLines","wordIndex","estimatedWordDuration","updatedLyrics","prevWord","fullGap","conservativeDuration","TimingUtils","getConservativeDuration","distributeSyllableTiming","prevLine","lastWordOfPrevLine","filter","startTimes","map","t","endTimes","min","max","updateLineTiming","estimatedDuration","some","s","currentTime","engine","KaraokeTimingEngine","silent","loadLyrics","position","getCurrentPosition","syllableIndex","isActive","lyricsText","metadata","lines","split","trim","lyricsLineNumber","pendingCaption","originalIndex","metadataInfo","text","trimmed","titleMatch","match","value","authorMatch","captionMatch","parseMetadataLine","metadataLine","id","lineNumber","title","author","captions","push","lyricLine","parseLyricsLine","caption","titleLineIndex","findIndex","titleLine","splice","unshift","index","eventLog","config","constructor","this","syllableWeights","first","middle","last","gaps","shortPause","mediumPause","longPause","minimums","syllableDuration","wordDuration","lineDuration","log","assignWordTiming","timestamp","events","isValidPosition","previousWord","getPreviousWord","actualDuration","finalizeWordTiming","expectedDuration","gap","detectGap","finalizeAllTiming","endTimestamp","lastWord","findLastTimedWord","estimateWordDuration","findCurrentSyllable","nextWord","getNextWord","getEventLog","getStats","totalDuration","averageWordDuration","eventCount","currentLine","nextLine","wordRef","weights","_","totalWeight","reduce","sum","weight","syllableDurations","toFixed","previousDuration","includes","syllableCount","i","elapsedTime","event","details","logEntry","padStart","padEnd","toString","console","TIMING","minDuration","maxDuration","collisionMargin","defaultDuration","lastSyllableWeight","firstSyllableWeight","weightIncrement","autoTiming","normalWordSpacing","phraseBreakSpacing","phraseBreakThreshold","maxNormalDuration","maxPhraseBreakDuration","conservativeGapUsage","lineEndingGapUsage","musical","restDuration","comma","period","breath","phrase","notePatterns","eighth","quarter","half","whole","conservativeMultiplier","editor","pixelThreshold","snapThreshold","viewportBuffer","dragSensitivity","validation","gapTolerance","overlapTolerance","durationTolerance","timingPrecision","refresh","playbackUpdateHz","fastModeMultiplier","dragUpdateHz","calculateSyllableWeights","Array","from","isPhraseBreak","gapSeconds","isLineEnding","constrainDuration","isWord","roundTiming","getPlaybackUpdateInterval","fastMode","getDragUpdateInterval","lineId","wordText","syllableTexts","syl","syllableText","fullWord","join","wordStartTime","totalMinDuration","warn","availableDuration","baseMinDuration","extraDuration","exports"],"mappings":"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"}